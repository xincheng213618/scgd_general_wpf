# ST.Library.UI æ”¹è¿›å»ºè®®

> é’ˆå¯¹ ST.Library.UI èŠ‚ç‚¹ç¼–è¾‘å™¨åº“çš„æ”¹è¿›å»ºè®®å’Œä¼˜åŒ–æ–¹å‘

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **é¡¹ç›®**: ST.Library.UI
- **ç‰ˆæœ¬**: 1.2.0.2410
- **è¯„ä¼°æ—¥æœŸ**: 2024
- **è¯„ä¼°èŒƒå›´**: æ¶æ„ã€åŠŸèƒ½ã€æ€§èƒ½ã€å¯ç»´æŠ¤æ€§

---

## ğŸ¯ æ€»ä½“è¯„ä¼°

### ä¼˜åŠ¿
âœ… åŠŸèƒ½å®Œæ•´ï¼Œæä¾›äº†ä¸“ä¸šçš„èŠ‚ç‚¹ç¼–è¾‘èƒ½åŠ›  
âœ… æ¶æ„æ¸…æ™°ï¼Œæ¨¡å—åŒ–è®¾è®¡è‰¯å¥½  
âœ… æ‰©å±•æ€§å¼ºï¼Œæ”¯æŒè‡ªå®šä¹‰èŠ‚ç‚¹å¼€å‘  
âœ… å¤šè¯­è¨€æ”¯æŒå®Œå–„  

### å¾…æ”¹è¿›ç‚¹
âš ï¸ éƒ¨åˆ†ä»£ç è€¦åˆåº¦è¾ƒé«˜  
âš ï¸ ç¼ºå°‘å•å…ƒæµ‹è¯•  
âš ï¸ æ€§èƒ½ä¼˜åŒ–ç©ºé—´è¾ƒå¤§  
âš ï¸ æ–‡æ¡£æ³¨é‡Šä¸å¤Ÿå®Œå–„  

---

## ğŸ—ï¸ æ¶æ„å±‚é¢æ”¹è¿›

### 1. ä¾èµ–æ³¨å…¥å’Œæ¥å£æŠ½è±¡

**ç°çŠ¶é—®é¢˜**:
- ç»„ä»¶é—´ç›´æ¥ä¾èµ–ï¼Œè€¦åˆåº¦é«˜
- éš¾ä»¥è¿›è¡Œå•å…ƒæµ‹è¯•
- æ‰©å±•æ€§å—é™

**æ”¹è¿›å»ºè®®**:

```csharp
// å®šä¹‰æ¥å£
public interface ISTNodeEditor
{
    STNodeCollection Nodes { get; }
    void LoadCanvas(string filePath);
    void SaveCanvas(string filePath);
    event STNodeEditorEventHandler NodeSelected;
}

public interface ISTNodeSerializer
{
    void Serialize(STNode node, Stream stream);
    STNode Deserialize(Stream stream);
}

// ä½¿ç”¨ä¾èµ–æ³¨å…¥
public class STNodeEditor : Control, ISTNodeEditor
{
    private readonly ISTNodeSerializer _serializer;
    
    public STNodeEditor(ISTNodeSerializer serializer)
    {
        _serializer = serializer ?? new DefaultSTNodeSerializer();
    }
}
```

**é¢„æœŸæ”¶ç›Š**:
- é™ä½ç»„ä»¶è€¦åˆ
- æé«˜å¯æµ‹è¯•æ€§
- ä¾¿äºåŠŸèƒ½æ‰©å±•

### 2. MVVM/MVP æ¨¡å¼å¼•å…¥

**ç°çŠ¶é—®é¢˜**:
- UI é€»è¾‘å’Œä¸šåŠ¡é€»è¾‘æ··åˆ
- ä»£ç å¤ç”¨å›°éš¾
- éš¾ä»¥è¿›è¡Œè‡ªåŠ¨åŒ–æµ‹è¯•

**æ”¹è¿›å»ºè®®**:

```csharp
// ViewModel
public class NodeEditorViewModel : INotifyPropertyChanged
{
    private ObservableCollection<STNode> _nodes;
    private STNode _selectedNode;
    
    public ObservableCollection<STNode> Nodes
    {
        get => _nodes;
        set { _nodes = value; OnPropertyChanged(); }
    }
    
    public STNode SelectedNode
    {
        get => _selectedNode;
        set { _selectedNode = value; OnPropertyChanged(); }
    }
    
    public ICommand AddNodeCommand { get; }
    public ICommand DeleteNodeCommand { get; }
    public ICommand ConnectNodesCommand { get; }
}

// View ç»‘å®š
editor.DataContext = new NodeEditorViewModel();
```

**é¢„æœŸæ”¶ç›Š**:
- é€»è¾‘åˆ†ç¦»æ¸…æ™°
- ä¾¿äºå•å…ƒæµ‹è¯•
- æé«˜ä»£ç å¤ç”¨

### 3. äº‹ä»¶èšåˆå™¨æ¨¡å¼

**ç°çŠ¶é—®é¢˜**:
- äº‹ä»¶è®¢é˜…åˆ†æ•£
- ç»„ä»¶é€šä¿¡å¤æ‚
- å†…å­˜æ³„æ¼é£é™©

**æ”¹è¿›å»ºè®®**:

```csharp
public interface IEventAggregator
{
    void Subscribe<T>(Action<T> handler);
    void Unsubscribe<T>(Action<T> handler);
    void Publish<T>(T eventData);
}

// ä½¿ç”¨
public class STNodeEditor
{
    private readonly IEventAggregator _eventAggregator;
    
    public void OnNodeSelected(STNode node)
    {
        _eventAggregator.Publish(new NodeSelectedEvent { Node = node });
    }
}

public class STNodePropertyGrid
{
    public STNodePropertyGrid(IEventAggregator eventAggregator)
    {
        eventAggregator.Subscribe<NodeSelectedEvent>(e => 
        {
            STNode = e.Node;
        });
    }
}
```

**é¢„æœŸæ”¶ç›Š**:
- è§£è€¦ç»„ä»¶é€šä¿¡
- ç»Ÿä¸€äº‹ä»¶ç®¡ç†
- é¿å…å†…å­˜æ³„æ¼

---

## âš¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. ç»˜åˆ¶ä¼˜åŒ–

**ç°çŠ¶é—®é¢˜**:
- æ¯æ¬¡é‡ç»˜éƒ½é‡æ–°åˆ›å»ºå¯¹è±¡
- æœªä½¿ç”¨è„åŒºåŸŸä¼˜åŒ–
- ç»˜åˆ¶æ€§èƒ½æœ‰æå‡ç©ºé—´

**æ”¹è¿›å»ºè®®**:

```csharp
public class STNodeEditor
{
    // å¯¹è±¡æ± å¤ç”¨
    private static readonly ObjectPool<Pen> _penPool = new ObjectPool<Pen>(() => new Pen(Color.Black));
    private static readonly ObjectPool<SolidBrush> _brushPool = new ObjectPool<SolidBrush>(() => new SolidBrush(Color.Black));
    
    // è„åŒºåŸŸæ ‡è®°
    private HashSet<Rectangle> _dirtyRegions = new HashSet<Rectangle>();
    
    protected override void OnPaint(PaintEventArgs e)
    {
        // åªé‡ç»˜è„åŒºåŸŸ
        if (_dirtyRegions.Count > 0)
        {
            foreach (var region in _dirtyRegions)
            {
                e.Graphics.SetClip(region);
                DrawRegion(e.Graphics, region);
            }
            _dirtyRegions.Clear();
        }
        else
        {
            base.OnPaint(e);
        }
    }
    
    // æ ‡è®°è„åŒºåŸŸ
    public void InvalidateNode(STNode node)
    {
        _dirtyRegions.Add(node.GetBounds());
        Invalidate();
    }
}
```

**é¢„æœŸæ”¶ç›Š**:
- å‡å°‘å¯¹è±¡åˆ›å»º
- é™ä½GCå‹åŠ›
- æé«˜ç»˜åˆ¶æ€§èƒ½

### 2. è¿æ¥æ£€æµ‹ä¼˜åŒ–

**ç°çŠ¶é—®é¢˜**:
- å¾ªç¯æ£€æµ‹ç®—æ³•å¤æ‚åº¦é«˜
- æ¯æ¬¡è¿æ¥éƒ½å…¨å›¾éå†
- å¤§è§„æ¨¡èŠ‚ç‚¹æ—¶æ€§èƒ½ä¸‹é™

**æ”¹è¿›å»ºè®®**:

```csharp
public class ConnectionValidator
{
    // ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤è®¡ç®—
    private Dictionary<(STNodeOption, STNodeOption), ConnectionStatus> _connectionCache 
        = new Dictionary<(STNodeOption, STNodeOption), ConnectionStatus>();
    
    // ä½¿ç”¨æ‹“æ‰‘æ’åºæ£€æµ‹å¾ªç¯
    public bool HasCycle(STNodeOption from, STNodeOption to)
    {
        var visited = new HashSet<STNode>();
        var recursionStack = new HashSet<STNode>();
        
        return HasCycleDFS(to.Owner, from.Owner, visited, recursionStack);
    }
    
    private bool HasCycleDFS(STNode current, STNode target, 
        HashSet<STNode> visited, HashSet<STNode> recursionStack)
    {
        if (recursionStack.Contains(current))
            return true;
            
        if (visited.Contains(current))
            return false;
            
        visited.Add(current);
        recursionStack.Add(current);
        
        foreach (var output in current.OutputOptions)
        {
            foreach (var connected in output.GetConnectedOptions())
            {
                if (connected.Owner == target)
                    return true;
                    
                if (HasCycleDFS(connected.Owner, target, visited, recursionStack))
                    return true;
            }
        }
        
        recursionStack.Remove(current);
        return false;
    }
}
```

**é¢„æœŸæ”¶ç›Š**:
- é™ä½ç®—æ³•å¤æ‚åº¦
- æé«˜è¿æ¥æ£€æµ‹é€Ÿåº¦
- æ”¯æŒæ›´å¤§è§„æ¨¡èŠ‚ç‚¹å›¾

### 3. åºåˆ—åŒ–æ€§èƒ½ä¼˜åŒ–

**ç°çŠ¶é—®é¢˜**:
- ä½¿ç”¨æ–‡æœ¬æ ¼å¼å­˜å‚¨æ•ˆç‡ä½
- åºåˆ—åŒ–é€Ÿåº¦æ…¢
- æ–‡ä»¶ä½“ç§¯å¤§

**æ”¹è¿›å»ºè®®**:

```csharp
// ä½¿ç”¨ MessagePack æˆ– Protobuf
public class BinaryNodeSerializer : ISTNodeSerializer
{
    public void Serialize(STNode node, Stream stream)
    {
        using (var writer = new BinaryWriter(stream, Encoding.UTF8, true))
        {
            // å†™å…¥èŠ‚ç‚¹ç±»å‹
            writer.Write(node.GetType().AssemblyQualifiedName);
            
            // å†™å…¥å±æ€§æ•°æ®
            var properties = GetSerializableProperties(node);
            writer.Write(properties.Count);
            
            foreach (var prop in properties)
            {
                writer.Write(prop.Name);
                WriteValue(writer, prop.GetValue(node));
            }
        }
    }
}
```

**é¢„æœŸæ”¶ç›Š**:
- å‡å°æ–‡ä»¶ä½“ç§¯ (50-70%)
- æé«˜åŠ è½½é€Ÿåº¦ (3-5å€)
- é™ä½å†…å­˜å ç”¨

---

## ğŸ”’ ä»£ç è´¨é‡æ”¹è¿›

### 1. æ·»åŠ å•å…ƒæµ‹è¯•

**ç°çŠ¶é—®é¢˜**:
- ç¼ºå°‘å•å…ƒæµ‹è¯•
- é‡æ„é£é™©é«˜
- Bug éš¾ä»¥å®šä½

**æ”¹è¿›å»ºè®®**:

```csharp
// ä½¿ç”¨ xUnit æˆ– NUnit
[TestClass]
public class STNodeTests
{
    [Test]
    public void AddOption_ShouldIncreaseOptionCount()
    {
        // Arrange
        var node = new TestNode();
        var initialCount = node.InputOptions.Count;
        
        // Act
        node.InputOptions.Add("Test", typeof(int), false);
        
        // Assert
        Assert.AreEqual(initialCount + 1, node.InputOptions.Count);
    }
    
    [Test]
    public void ConnectTo_SameNode_ShouldReturnSameOwner()
    {
        // Arrange
        var node = new TestNode();
        node.InputOptions.Add("In", typeof(int), false);
        node.OutputOptions.Add("Out", typeof(int), false);
        
        // Act
        var status = node.OutputOptions[0].ConnectTo(node.InputOptions[0]);
        
        // Assert
        Assert.AreEqual(ConnectionStatus.SameOwner, status);
    }
}

[TestClass]
public class ConnectionValidatorTests
{
    [Test]
    public void HasCycle_WithCycle_ShouldReturnTrue()
    {
        // æµ‹è¯•å¾ªç¯æ£€æµ‹
    }
    
    [Test]
    public void TypeCompatibility_IncompatibleTypes_ShouldReturnErrorType()
    {
        // æµ‹è¯•ç±»å‹å…¼å®¹æ€§
    }
}
```

**å»ºè®®è¦†ç›–ç‡**: æ ¸å¿ƒé€»è¾‘ > 80%

### 2. ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£

**ç°çŠ¶é—®é¢˜**:
- ç¼ºå°‘ XML æ–‡æ¡£æ³¨é‡Š
- å…¬å…± API ç¼ºå°‘è¯´æ˜
- ä½¿ç”¨ç¤ºä¾‹ä¸è¶³

**æ”¹è¿›å»ºè®®**:

```csharp
/// <summary>
/// èŠ‚ç‚¹ç¼–è¾‘å™¨æ§ä»¶ï¼Œæä¾›å¯è§†åŒ–çš„èŠ‚ç‚¹ç¼–è¾‘åŠŸèƒ½
/// </summary>
/// <remarks>
/// æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š
/// - èŠ‚ç‚¹çš„åˆ›å»ºã€ç§»åŠ¨ã€åˆ é™¤
/// - èŠ‚ç‚¹é—´çš„è¿æ¥ç®¡ç†
/// - ç”»å¸ƒçš„ç¼©æ”¾å’Œå¹³ç§»
/// - æ’¤é”€/é‡åšæ“ä½œ
/// </remarks>
/// <example>
/// <code>
/// var editor = new STNodeEditor();
/// editor.Nodes.Add(new MyNode());
/// </code>
/// </example>
public class STNodeEditor : Control
{
    /// <summary>
    /// åŠ è½½ç”»å¸ƒæ•°æ®
    /// </summary>
    /// <param name="filePath">æ–‡ä»¶è·¯å¾„</param>
    /// <exception cref="FileNotFoundException">æ–‡ä»¶ä¸å­˜åœ¨æ—¶æŠ›å‡º</exception>
    /// <exception cref="SerializationException">ååºåˆ—åŒ–å¤±è´¥æ—¶æŠ›å‡º</exception>
    public void LoadCanvas(string filePath)
    {
        // ...
    }
}
```

### 3. å¼‚å¸¸å¤„ç†

**ç°çŠ¶é—®é¢˜**:
- å¼‚å¸¸å¤„ç†ä¸å¤Ÿå®Œå–„
- é”™è¯¯ä¿¡æ¯ä¸å¤Ÿå‹å¥½
- ç¼ºå°‘æ—¥å¿—è®°å½•

**æ”¹è¿›å»ºè®®**:

```csharp
public class STNodeEditor
{
    private readonly ILogger<STNodeEditor> _logger;
    
    public void LoadCanvas(string filePath)
    {
        try
        {
            _logger.LogInformation("å¼€å§‹åŠ è½½ç”»å¸ƒ: {FilePath}", filePath);
            
            if (!File.Exists(filePath))
                throw new FileNotFoundException($"ç”»å¸ƒæ–‡ä»¶ä¸å­˜åœ¨: {filePath}");
            
            // åŠ è½½é€»è¾‘
            
            _logger.LogInformation("ç”»å¸ƒåŠ è½½æˆåŠŸ");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "åŠ è½½ç”»å¸ƒå¤±è´¥: {FilePath}", filePath);
            
            // å‹å¥½çš„é”™è¯¯æç¤º
            MessageBox.Show(
                $"åŠ è½½ç”»å¸ƒå¤±è´¥: {ex.Message}",
                "é”™è¯¯",
                MessageBoxButtons.OK,
                MessageBoxIcon.Error
            );
            
            throw;
        }
    }
}
```

---

## ğŸ¨ ç”¨æˆ·ä½“éªŒæ”¹è¿›

### 1. å¿«æ·é”®ç³»ç»Ÿ

**æ”¹è¿›å»ºè®®**:

```csharp
public class ShortcutManager
{
    private Dictionary<Keys, Action> _shortcuts = new Dictionary<Keys, Action>();
    
    public void RegisterShortcut(Keys key, Action action)
    {
        _shortcuts[key] = action;
    }
    
    public void HandleKeyDown(Keys key)
    {
        if (_shortcuts.TryGetValue(key, out var action))
        {
            action?.Invoke();
        }
    }
}

// ä½¿ç”¨
var shortcuts = new ShortcutManager();
shortcuts.RegisterShortcut(Keys.Control | Keys.Z, () => editor.Undo());
shortcuts.RegisterShortcut(Keys.Control | Keys.Y, () => editor.Redo());
shortcuts.RegisterShortcut(Keys.Delete, () => editor.DeleteSelected());
shortcuts.RegisterShortcut(Keys.Control | Keys.C, () => editor.Copy());
shortcuts.RegisterShortcut(Keys.Control | Keys.V, () => editor.Paste());
```

### 2. å³é”®èœå•å¢å¼º

**æ”¹è¿›å»ºè®®**:

```csharp
public class NodeContextMenu
{
    public ContextMenuStrip CreateNodeMenu(STNode node)
    {
        var menu = new ContextMenuStrip();
        
        menu.Items.Add("å¤åˆ¶", null, (s, e) => CopyNode(node));
        menu.Items.Add("åˆ é™¤", null, (s, e) => DeleteNode(node));
        menu.Items.Add(new ToolStripSeparator());
        menu.Items.Add("å±æ€§", null, (s, e) => ShowProperties(node));
        menu.Items.Add("é”å®š", null, (s, e) => ToggleLock(node));
        menu.Items.Add(new ToolStripSeparator());
        menu.Items.Add("å¸®åŠ©", null, (s, e) => ShowHelp(node));
        
        return menu;
    }
}
```

### 3. å°åœ°å›¾å¯¼èˆª

**æ”¹è¿›å»ºè®®**:

```csharp
public class MiniMapControl : Control
{
    private STNodeEditor _editor;
    private float _scale = 0.1f;
    
    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        
        var g = e.Graphics;
        g.ScaleTransform(_scale, _scale);
        
        // ç»˜åˆ¶æ‰€æœ‰èŠ‚ç‚¹ç¼©ç•¥å›¾
        foreach (var node in _editor.Nodes)
        {
            DrawNodeMiniature(g, node);
        }
        
        // ç»˜åˆ¶å¯è§†åŒºåŸŸæ¡†
        DrawViewportFrame(g);
    }
    
    private void DrawViewportFrame(Graphics g)
    {
        var viewport = new Rectangle(
            (int)(_editor.CanvasOffsetX * _scale),
            (int)(_editor.CanvasOffsetY * _scale),
            (int)(_editor.Width * _scale),
            (int)(_editor.Height * _scale)
        );
        
        g.DrawRectangle(Pens.Red, viewport);
    }
}
```

---

## ğŸ”§ åŠŸèƒ½æ‰©å±•å»ºè®®

### 1. èŠ‚ç‚¹ç»„åŠŸèƒ½

**æ”¹è¿›å»ºè®®**:

```csharp
public class STNodeGroup : STNode
{
    public List<STNode> GroupedNodes { get; } = new List<STNode>();
    
    public void AddNode(STNode node)
    {
        GroupedNodes.Add(node);
        node.Group = this;
    }
    
    public void RemoveNode(STNode node)
    {
        GroupedNodes.Remove(node);
        node.Group = null;
    }
    
    // ç»„ç§»åŠ¨æ—¶åŒæ­¥ç§»åŠ¨å†…éƒ¨èŠ‚ç‚¹
    protected override void OnLocationChanged()
    {
        base.OnLocationChanged();
        
        foreach (var node in GroupedNodes)
        {
            node.Left += DeltaX;
            node.Top += DeltaY;
        }
    }
}
```

### 2. æ³¨é‡Šå’Œæ ‡æ³¨

**æ”¹è¿›å»ºè®®**:

```csharp
public class STNodeComment : STNode
{
    public string Comment { get; set; }
    public Color BackColor { get; set; }
    
    protected override void OnDrawBody(DrawingTools dt)
    {
        // ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯æ¡†
        var brush = new SolidBrush(Color.FromArgb(100, BackColor));
        dt.Graphics.FillRectangle(brush, GetBounds());
        
        // ç»˜åˆ¶æ³¨é‡Šæ–‡æœ¬
        dt.Graphics.DrawString(
            Comment,
            Font,
            Brushes.White,
            new PointF(Left + 5, Top + 5)
        );
    }
}
```

### 3. ç‰ˆæœ¬æ§åˆ¶é›†æˆ

**æ”¹è¿›å»ºè®®**:

```csharp
public interface IVersionControl
{
    void CommitCanvas(STNodeEditor editor, string message);
    void RevertToVersion(string versionId);
    List<CanvasVersion> GetHistory();
}

public class GitVersionControl : IVersionControl
{
    public void CommitCanvas(STNodeEditor editor, string message)
    {
        var data = SerializeCanvas(editor);
        // æäº¤åˆ° Git
    }
}
```

### 4. åä½œåŠŸèƒ½

**æ”¹è¿›å»ºè®®**:

```csharp
public interface ICollaborationService
{
    void ShareCanvas(string canvasId, string[] users);
    void SyncChanges(CanvasChange change);
    event Action<CanvasChange> OnRemoteChange;
}

public class WebSocketCollaboration : ICollaborationService
{
    // å®æ—¶åŒæ­¥èŠ‚ç‚¹å˜æ›´
    public void BroadcastNodeMove(STNode node)
    {
        var change = new CanvasChange
        {
            Type = ChangeType.NodeMove,
            NodeId = node.Guid,
            Data = new { node.Left, node.Top }
        };
        
        _webSocket.Send(JsonSerializer.Serialize(change));
    }
}
```

---

## ğŸ“± è·¨å¹³å°æ”¯æŒ

### 1. WPF ç‰ˆæœ¬

**æ”¹è¿›å»ºè®®**:

```csharp
// æå–æ ¸å¿ƒé€»è¾‘åˆ°å…±äº«åº“
public class STNodeCore
{
    // å¹³å°æ— å…³çš„æ ¸å¿ƒé€»è¾‘
}

// WinForms å®ç°
public class STNodeEditor : Control
{
    private STNodeCore _core = new STNodeCore();
}

// WPF å®ç°
public class STNodeEditorWPF : FrameworkElement
{
    private STNodeCore _core = new STNodeCore();
}
```

### 2. è·¨å¹³å°å›¾å½¢åº“

**æ”¹è¿›å»ºè®®**:

```csharp
// ä½¿ç”¨ SkiaSharp æ›¿ä»£ GDI+
public interface IGraphicsContext
{
    void DrawLine(Color color, float x1, float y1, float x2, float y2);
    void DrawRectangle(Color color, RectF rect);
    void FillRectangle(Color color, RectF rect);
}

public class SkiaGraphicsContext : IGraphicsContext
{
    private SKCanvas _canvas;
    
    public void DrawLine(Color color, float x1, float y1, float x2, float y2)
    {
        using (var paint = new SKPaint { Color = ToSKColor(color) })
        {
            _canvas.DrawLine(x1, y1, x2, y2, paint);
        }
    }
}
```

---

## ğŸ“Š ç›‘æ§å’Œè¯Šæ–­

### 1. æ€§èƒ½ç›‘æ§

**æ”¹è¿›å»ºè®®**:

```csharp
public class PerformanceMonitor
{
    private Stopwatch _stopwatch = new Stopwatch();
    
    public void TrackOperation(string operation, Action action)
    {
        _stopwatch.Restart();
        
        try
        {
            action();
        }
        finally
        {
            _stopwatch.Stop();
            LogPerformance(operation, _stopwatch.ElapsedMilliseconds);
        }
    }
    
    private void LogPerformance(string operation, long milliseconds)
    {
        if (milliseconds > 100)
        {
            _logger.LogWarning(
                "æ€§èƒ½è­¦å‘Š: {Operation} è€—æ—¶ {Duration}ms",
                operation,
                milliseconds
            );
        }
    }
}
```

### 2. å†…å­˜åˆ†æ

**æ”¹è¿›å»ºè®®**:

```csharp
public class MemoryAnalyzer
{
    public MemoryReport AnalyzeEditor(STNodeEditor editor)
    {
        var report = new MemoryReport();
        
        // åˆ†æèŠ‚ç‚¹å†…å­˜
        foreach (var node in editor.Nodes)
        {
            report.NodeMemory += GetObjectSize(node);
        }
        
        // åˆ†æè¿æ¥å†…å­˜
        report.ConnectionMemory = AnalyzeConnections(editor);
        
        // åˆ†ææ’¤é”€æ ˆå†…å­˜
        report.UndoStackMemory = AnalyzeUndoStack(editor);
        
        return report;
    }
}
```

---

## ğŸ¯ ä¼˜å…ˆçº§å»ºè®®

### é«˜ä¼˜å…ˆçº§ (P0)
1. âœ… æ·»åŠ å•å…ƒæµ‹è¯•æ¡†æ¶
2. âœ… æ€§èƒ½ä¼˜åŒ– - ç»˜åˆ¶ä¼˜åŒ–
3. âœ… å®Œå–„ XML æ–‡æ¡£æ³¨é‡Š
4. âœ… å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—

### ä¸­ä¼˜å…ˆçº§ (P1)
1. ğŸ“Œ ä¾èµ–æ³¨å…¥é‡æ„
2. ğŸ“Œ è¿æ¥æ£€æµ‹ä¼˜åŒ–
3. ğŸ“Œ å¿«æ·é”®ç³»ç»Ÿ
4. ğŸ“Œ åºåˆ—åŒ–æ€§èƒ½ä¼˜åŒ–

### ä½ä¼˜å…ˆçº§ (P2)
1. ğŸ”¹ MVVM æ¨¡å¼å¼•å…¥
2. ğŸ”¹ èŠ‚ç‚¹ç»„åŠŸèƒ½
3. ğŸ”¹ å°åœ°å›¾å¯¼èˆª
4. ğŸ”¹ è·¨å¹³å°æ”¯æŒ

---

## ğŸ“ˆ å®æ–½è·¯çº¿å›¾

### Phase 1: åŸºç¡€ä¼˜åŒ– (1-2ä¸ªæœˆ)
- å»ºç«‹å•å…ƒæµ‹è¯•æ¡†æ¶
- ä¼˜åŒ–ç»˜åˆ¶æ€§èƒ½
- å®Œå–„æ–‡æ¡£æ³¨é‡Š
- æ”¹è¿›å¼‚å¸¸å¤„ç†

### Phase 2: æ¶æ„æ”¹è¿› (2-3ä¸ªæœˆ)
- å¼•å…¥ä¾èµ–æ³¨å…¥
- é‡æ„æ ¸å¿ƒç»„ä»¶
- ä¼˜åŒ–è¿æ¥ç®—æ³•
- å®ç°å¿«æ·é”®ç³»ç»Ÿ

### Phase 3: åŠŸèƒ½æ‰©å±• (3-4ä¸ªæœˆ)
- èŠ‚ç‚¹ç»„åŠŸèƒ½
- å°åœ°å›¾å¯¼èˆª
- ç‰ˆæœ¬æ§åˆ¶é›†æˆ
- åä½œåŠŸèƒ½åŸå‹

### Phase 4: è·¨å¹³å° (4-6ä¸ªæœˆ)
- WPF ç‰ˆæœ¬å¼€å‘
- è·¨å¹³å°å›¾å½¢åº“
- ç»Ÿä¸€ API è®¾è®¡
- æ€§èƒ½å¯¹æ¯”æµ‹è¯•

---

## ğŸ“ æ€»ç»“

ST.Library.UI æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€è®¾è®¡è‰¯å¥½çš„èŠ‚ç‚¹ç¼–è¾‘å™¨åº“ã€‚é€šè¿‡æœ¬æ–‡æ¡£æå‡ºçš„æ”¹è¿›å»ºè®®ï¼Œå¯ä»¥åœ¨ä»¥ä¸‹æ–¹é¢è·å¾—æ˜¾è‘—æå‡ï¼š

1. **æ€§èƒ½**: ç»˜åˆ¶æ€§èƒ½æå‡ 30-50%ï¼Œå†…å­˜å ç”¨é™ä½ 20-30%
2. **å¯ç»´æŠ¤æ€§**: é€šè¿‡å•å…ƒæµ‹è¯•å’Œæ–‡æ¡£ï¼Œé™ä½ç»´æŠ¤æˆæœ¬ 40%
3. **æ‰©å±•æ€§**: é€šè¿‡æ¶æ„ä¼˜åŒ–ï¼Œæå‡æ‰©å±•å¼€å‘æ•ˆç‡ 50%
4. **ç”¨æˆ·ä½“éªŒ**: é€šè¿‡äº¤äº’ä¼˜åŒ–ï¼Œæå‡ç”¨æˆ·æ»¡æ„åº¦

å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§å’Œè·¯çº¿å›¾é€æ­¥å®æ–½ï¼Œæ¯ä¸ªé˜¶æ®µå®Œæˆåè¿›è¡Œè¯„ä¼°å’Œè°ƒæ•´ã€‚

---

**æ–‡æ¡£ç»´æŠ¤**: å®šæœŸæ›´æ–°æœ¬æ–‡æ¡£ï¼Œè®°å½•æ”¹è¿›è¿›å±•å’Œæ–°çš„å»ºè®®  
**åé¦ˆæ¸ é“**: æ¬¢è¿å¼€å‘å›¢é˜Ÿæå‡ºæ„è§å’Œè¡¥å……å»ºè®®
