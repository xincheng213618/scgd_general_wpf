# FlowEngineLib æ”¹è¿›å»ºè®®

> åŸºäºä»£ç åˆ†æçš„æ”¹è¿›å»ºè®®å’Œä¼˜åŒ–æ–¹å‘

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºå¯¹ FlowEngineLib é¡¹ç›®çš„æ·±å…¥åˆ†æï¼Œæå‡ºäº†ä¸€ç³»åˆ—æ”¹è¿›å»ºè®®ï¼Œæ—¨åœ¨æå‡ä»£ç è´¨é‡ã€æ€§èƒ½ã€å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

## ğŸ¯ æ”¹è¿›ä¼˜å…ˆçº§

- ğŸ”´ **é«˜ä¼˜å…ˆçº§** - å½±å“ç³»ç»Ÿç¨³å®šæ€§å’Œæ€§èƒ½ï¼Œå»ºè®®ä¼˜å…ˆå¤„ç†
- ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§** - æå‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§
- ğŸŸ¢ **ä½ä¼˜å…ˆçº§** - å¢å¼ºåŠŸèƒ½å’Œç”¨æˆ·ä½“éªŒ

---

## 1. æ¶æ„ä¼˜åŒ– ğŸ”´

### 1.1 ä¾èµ–æ³¨å…¥æ”¹é€ 

**ç°çŠ¶é—®é¢˜**:
- å¤§é‡ä½¿ç”¨å•ä¾‹æ¨¡å¼ (FlowNodeManager.Instance, FlowServiceManager.Instance)
- ç´§è€¦åˆï¼Œä¸åˆ©äºå•å…ƒæµ‹è¯•
- éš¾ä»¥è¿›è¡Œæ¨¡æ‹Ÿå’Œéš”ç¦»æµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
// å½“å‰æ–¹å¼
var manager = FlowNodeManager.Instance;

// å»ºè®®æ”¹ä¸ºä¾èµ–æ³¨å…¥
public class FlowEngineControl
{
    private readonly IFlowNodeManager _nodeManager;
    private readonly IFlowServiceManager _serviceManager;
    
    public FlowEngineControl(
        IFlowNodeManager nodeManager,
        IFlowServiceManager serviceManager)
    {
        _nodeManager = nodeManager;
        _serviceManager = serviceManager;
    }
}
```

**ä¼˜åŠ¿**:
- æé«˜å¯æµ‹è¯•æ€§
- é™ä½è€¦åˆåº¦
- æ”¯æŒå¤šå®ä¾‹åœºæ™¯
- ä¾¿äºMockå’Œå•å…ƒæµ‹è¯•

### 1.2 æ¥å£æŠ½è±¡

**æ”¹è¿›å»ºè®®**:
å®šä¹‰æ ¸å¿ƒæ¥å£ï¼Œæé«˜æ‰©å±•æ€§ï¼š

```csharp
// èŠ‚ç‚¹æ¥å£
public interface IFlowNode
{
    string NodeID { get; }
    string NodeName { get; set; }
    string NodeType { get; }
    void Execute(IFlowContext context);
}

// æµç¨‹å¼•æ“æ¥å£
public interface IFlowEngine
{
    Task<FlowResult> RunFlowAsync(string flowName, CancellationToken ct);
    void StopFlow(string flowName);
    bool IsRunning(string flowName);
}

// è®¾å¤‡ç®¡ç†æ¥å£
public interface IDeviceManager
{
    void RegisterDevice(IDevice device);
    IDevice GetDevice(string deviceCode);
    Task<DeviceStatus> GetDeviceStatusAsync(string deviceCode);
}
```

### 1.3 äº‹ä»¶æ€»çº¿æ¨¡å¼

**ç°çŠ¶é—®é¢˜**:
- äº‹ä»¶å¤„ç†åˆ†æ•£åœ¨å„ä¸ªèŠ‚ç‚¹
- éš¾ä»¥ç»Ÿä¸€ç®¡ç†å’Œç›‘æ§

**æ”¹è¿›å»ºè®®**:
å®ç°é›†ä¸­å¼äº‹ä»¶æ€»çº¿ï¼š

```csharp
public interface IEventBus
{
    void Publish<TEvent>(TEvent eventData) where TEvent : class;
    void Subscribe<TEvent>(Action<TEvent> handler) where TEvent : class;
    void Unsubscribe<TEvent>(Action<TEvent> handler) where TEvent : class;
}

// ä½¿ç”¨ç¤ºä¾‹
_eventBus.Publish(new FlowStartedEvent { FlowName = "MainFlow" });
_eventBus.Subscribe<NodeExecutedEvent>(OnNodeExecuted);
```

---

## 2. æ€§èƒ½ä¼˜åŒ– ğŸ”´

### 2.1 å¼‚æ­¥ç¼–ç¨‹æ”¹è¿›

**ç°çŠ¶é—®é¢˜**:
- éƒ¨åˆ†åŒæ­¥æ–¹æ³•é˜»å¡çº¿ç¨‹
- æœªå……åˆ†åˆ©ç”¨å¼‚æ­¥ç‰¹æ€§

**æ”¹è¿›å»ºè®®**:
```csharp
// å½“å‰
public void DoServerWork(CVStartCFC cfc)
{
    var result = SendCommand(); // åŒæ­¥ç­‰å¾…
    ProcessResult(result);
}

// æ”¹è¿›å
public async Task DoServerWorkAsync(CVStartCFC cfc, CancellationToken ct)
{
    var result = await SendCommandAsync(ct);
    await ProcessResultAsync(result, ct);
}
```

### 2.2 å†…å­˜ä¼˜åŒ–

**æ”¹è¿›å»ºè®®**:

1. **å¯¹è±¡æ± **:
```csharp
public class FlowContextPool
{
    private static readonly ObjectPool<CVStartCFC> _cfcPool = 
        ObjectPool.Create<CVStartCFC>();
    
    public static CVStartCFC Rent() => _cfcPool.Get();
    public static void Return(CVStartCFC cfc) => _cfcPool.Return(cfc);
}
```

2. **Span<T> å’Œ Memory<T>**:
```csharp
// å›¾åƒæ•°æ®å¤„ç†
public void ProcessImage(Span<byte> imageData)
{
    // é¿å…æ•°ç»„å¤åˆ¶
}
```

3. **åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡**:
```csharp
public class CameraNode : IDisposable
{
    private byte[] _imageBuffer;
    
    public void Dispose()
    {
        _imageBuffer = null;
        GC.Collect();
    }
}
```

### 2.3 å¹¶å‘æ§åˆ¶ä¼˜åŒ–

**æ”¹è¿›å»ºè®®**:
```csharp
// ä½¿ç”¨SemaphoreSlimæ§åˆ¶å¹¶å‘
private readonly SemaphoreSlim _semaphore = new(5, 5);

public async Task ExecuteAsync()
{
    await _semaphore.WaitAsync();
    try
    {
        // æ‰§è¡Œä»»åŠ¡
    }
    finally
    {
        _semaphore.Release();
    }
}
```

---

## 3. é”™è¯¯å¤„ç†ä¸æ—¥å¿— ğŸ”´

### 3.1 ç»Ÿä¸€å¼‚å¸¸å¤„ç†

**æ”¹è¿›å»ºè®®**:
```csharp
// å®šä¹‰å¼‚å¸¸å±‚æ¬¡
public class FlowEngineException : Exception
{
    public string NodeName { get; set; }
    public string FlowName { get; set; }
}

public class NodeExecutionException : FlowEngineException { }
public class DeviceNotReadyException : FlowEngineException { }
public class MQTTConnectionException : FlowEngineException { }

// å…¨å±€å¼‚å¸¸å¤„ç†å™¨
public class FlowExceptionHandler
{
    public async Task<FlowResult> ExecuteWithHandlingAsync(
        Func<Task<FlowResult>> action)
    {
        try
        {
            return await action();
        }
        catch (DeviceNotReadyException ex)
        {
            // é‡è¯•é€»è¾‘
            return await RetryAsync(action, maxRetries: 3);
        }
        catch (FlowEngineException ex)
        {
            logger.Error($"Flow error: {ex.Message}", ex);
            return FlowResult.Failed(ex.Message);
        }
    }
}
```

### 3.2 ç»“æ„åŒ–æ—¥å¿—

**æ”¹è¿›å»ºè®®**:
```csharp
// ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—ï¼ˆSerilogï¼‰
logger.Information(
    "Node {NodeName} executed in {Duration}ms with result {Result}",
    nodeName,
    duration,
    result);

// æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
using (LogContext.PushProperty("FlowName", flowName))
using (LogContext.PushProperty("SerialNumber", serialNumber))
{
    logger.Information("Processing flow");
}
```

### 3.3 é“¾è·¯è¿½è¸ª

**æ”¹è¿›å»ºè®®**:
```csharp
public class FlowTracer
{
    public string TraceId { get; } = Guid.NewGuid().ToString();
    
    public void TraceNodeExecution(string nodeName, TimeSpan duration)
    {
        logger.Information(
            "[{TraceId}] Node {NodeName} executed in {Duration}ms",
            TraceId, nodeName, duration.TotalMilliseconds);
    }
}
```

---

## 4. ä»£ç è´¨é‡ ğŸŸ¡

### 4.1 å‘½åè§„èŒƒ

**ç°çŠ¶é—®é¢˜**:
- éƒ¨åˆ†å˜é‡ä½¿ç”¨æ‹¼éŸ³å‘½å
- å‘½åä¸ä¸€è‡´

**æ”¹è¿›å»ºè®®**:
```csharp
// ä¸æ¨è
public class POINode  // æ‹¼éŸ³ç¼©å†™
public float m_begin_val;  // ä¸‹åˆ’çº¿å‘½å

// æ¨è
public class PointOfInterestNode
public float BeginValue { get; set; }  // Pascalå‘½å
```

### 4.2 ä»£ç å¤ç”¨

**æ”¹è¿›å»ºè®®**:
```csharp
// æå–å…¬å…±é€»è¾‘
public abstract class BaseNode
{
    protected async Task<TResult> ExecuteWithTimeoutAsync<TResult>(
        Func<Task<TResult>> action,
        TimeSpan timeout)
    {
        using var cts = new CancellationTokenSource(timeout);
        return await action().WaitAsync(cts.Token);
    }
    
    protected void ValidateInputs(params object[] inputs)
    {
        foreach (var input in inputs)
        {
            if (input == null)
                throw new ArgumentNullException();
        }
    }
}
```

### 4.3 SOLIDåŸåˆ™åº”ç”¨

**å•ä¸€èŒè´£åŸåˆ™**:
```csharp
// åˆ†ç¦»èŒè´£
public class NodeExecutor  // åªè´Ÿè´£æ‰§è¡Œ
public class NodeValidator  // åªè´Ÿè´£éªŒè¯
public class NodeSerializer  // åªè´Ÿè´£åºåˆ—åŒ–
```

**å¼€é—­åŸåˆ™**:
```csharp
// ä½¿ç”¨ç­–ç•¥æ¨¡å¼
public interface INodeExecutionStrategy
{
    Task ExecuteAsync(IFlowNode node);
}

public class SyncExecutionStrategy : INodeExecutionStrategy { }
public class AsyncExecutionStrategy : INodeExecutionStrategy { }
```

---

## 5. æµ‹è¯•å®Œå–„ ğŸŸ¡

### 5.1 å•å…ƒæµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class FlowEngineControlTests
{
    private Mock<IFlowNodeManager> _nodeManagerMock;
    private FlowEngineControl _sut;
    
    [TestInitialize]
    public void Setup()
    {
        _nodeManagerMock = new Mock<IFlowNodeManager>();
        _sut = new FlowEngineControl(_nodeManagerMock.Object);
    }
    
    [TestMethod]
    public async Task RunFlow_ValidFlow_ReturnsSuccess()
    {
        // Arrange
        var flowName = "TestFlow";
        
        // Act
        var result = await _sut.RunFlowAsync(flowName);
        
        // Assert
        Assert.IsTrue(result.Success);
    }
}
```

### 5.2 é›†æˆæµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class FlowEngineIntegrationTests
{
    [TestMethod]
    public async Task EndToEnd_CameraToAlgorithm_Success()
    {
        // æµ‹è¯•å®Œæ•´æµç¨‹
        var engine = CreateTestEngine();
        var result = await engine.RunFlowAsync("CameraAlgorithmFlow");
        
        Assert.IsNotNull(result.OutputData);
    }
}
```

### 5.3 æ€§èƒ½æµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    public void FlowExecution_1000Nodes_CompletesIn1Second()
    {
        var sw = Stopwatch.StartNew();
        
        // æ‰§è¡Œæµ‹è¯•
        engine.RunFlow("LargeFlow");
        
        sw.Stop();
        Assert.IsTrue(sw.ElapsedMilliseconds < 1000);
    }
}
```

---

## 6. é…ç½®ç®¡ç† ğŸŸ¡

### 6.1 é…ç½®æ–‡ä»¶ç»“æ„åŒ–

**æ”¹è¿›å»ºè®®**:
```json
{
  "FlowEngine": {
    "MaxConcurrentFlows": 10,
    "FlowTimeout": 300,
    "EnableMetrics": true,
    "ThreadPool": {
      "MinThreads": 1,
      "MaxThreads": 5
    }
  },
  "MQTT": {
    "Host": "localhost",
    "Port": 1883,
    "Username": "user",
    "Password": "pass",
    "ClientId": "FlowEngine",
    "QoS": 1,
    "RetainMessages": false,
    "Reconnect": {
      "Enabled": true,
      "MaxAttempts": 5,
      "DelaySeconds": 3
    }
  },
  "Logging": {
    "Level": "Information",
    "Path": "./logs",
    "RollingInterval": "Day",
    "RetainDays": 7
  }
}
```

### 6.2 é…ç½®éªŒè¯

**æ”¹è¿›å»ºè®®**:
```csharp
public class FlowEngineOptions
{
    [Required]
    [Range(1, 100)]
    public int MaxConcurrentFlows { get; set; }
    
    [Required]
    public MQTTOptions MQTT { get; set; }
}

// éªŒè¯é…ç½®
services.AddOptions<FlowEngineOptions>()
    .BindConfiguration("FlowEngine")
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

---

## 7. æ–‡æ¡£å®Œå–„ ğŸŸ¡

### 7.1 XMLæ³¨é‡Š

**æ”¹è¿›å»ºè®®**:
```csharp
/// <summary>
/// æµç¨‹å¼•æ“æ§åˆ¶å™¨ï¼Œè´Ÿè´£æµç¨‹çš„åŠ è½½ã€æ‰§è¡Œå’Œç®¡ç†
/// </summary>
/// <remarks>
/// æ”¯æŒåŒæ—¶è¿è¡Œå¤šä¸ªæµç¨‹ï¼Œæ¯ä¸ªæµç¨‹æœ‰ç‹¬ç«‹çš„æ‰§è¡Œä¸Šä¸‹æ–‡
/// </remarks>
public class FlowEngineControl
{
    /// <summary>
    /// è¿è¡ŒæŒ‡å®šçš„æµç¨‹
    /// </summary>
    /// <param name="flowName">æµç¨‹åç§°</param>
    /// <param name="parameters">æµç¨‹å‚æ•°</param>
    /// <param name="cancellationToken">å–æ¶ˆä»¤ç‰Œ</param>
    /// <returns>æµç¨‹æ‰§è¡Œç»“æœ</returns>
    /// <exception cref="FlowNotFoundException">æµç¨‹ä¸å­˜åœ¨</exception>
    /// <exception cref="FlowExecutionException">æµç¨‹æ‰§è¡Œå¤±è´¥</exception>
    public async Task<FlowResult> RunFlowAsync(
        string flowName,
        Dictionary<string, object> parameters = null,
        CancellationToken cancellationToken = default)
    {
        // å®ç°
    }
}
```

### 7.2 ä½¿ç”¨ç¤ºä¾‹

åœ¨å…³é”®ç±»ä¸­æ·»åŠ ä½¿ç”¨ç¤ºä¾‹ï¼š

```csharp
/// <example>
/// <code>
/// var engine = new FlowEngineControl(nodeEditor);
/// engine.Finished += (s, e) => Console.WriteLine($"Flow {e.FlowName} completed");
/// await engine.RunFlowAsync("MainFlow");
/// </code>
/// </example>
```

---

## 8. å®‰å…¨æ€§æ”¹è¿› ğŸŸ¡

### 8.1 è¾“å…¥éªŒè¯

**æ”¹è¿›å»ºè®®**:
```csharp
public class InputValidator
{
    public void ValidateFlowName(string flowName)
    {
        if (string.IsNullOrWhiteSpace(flowName))
            throw new ArgumentException("Flow name cannot be empty");
            
        if (flowName.Length > 100)
            throw new ArgumentException("Flow name too long");
            
        if (!Regex.IsMatch(flowName, @"^[a-zA-Z0-9_-]+$"))
            throw new ArgumentException("Invalid flow name format");
    }
}
```

### 8.2 MQTTå®‰å…¨

**æ”¹è¿›å»ºè®®**:
```csharp
public class SecureMQTTHelper
{
    public static void SetSecureConfig(
        string host,
        int port,
        string username,
        string password,
        bool useTls = true,
        string caCertPath = null)
    {
        var options = new MqttClientOptionsBuilder()
            .WithTcpServer(host, port)
            .WithCredentials(username, password);
            
        if (useTls)
        {
            options.WithTls(new MqttClientOptionsBuilderTlsParameters
            {
                UseTls = true,
                CertificateValidationHandler = ValidateCertificate
            });
        }
    }
}
```

---

## 9. ç”¨æˆ·ä½“éªŒ ğŸŸ¢

### 9.1 è¿›åº¦åé¦ˆ

**æ”¹è¿›å»ºè®®**:
```csharp
public interface IFlowProgress
{
    void Report(FlowProgressInfo progress);
}

public class FlowProgressInfo
{
    public string FlowName { get; set; }
    public string CurrentNode { get; set; }
    public int CompletedNodes { get; set; }
    public int TotalNodes { get; set; }
    public double PercentComplete => (double)CompletedNodes / TotalNodes * 100;
}

// ä½¿ç”¨
var progress = new Progress<FlowProgressInfo>(p => {
    Console.WriteLine($"{p.PercentComplete:F1}% - {p.CurrentNode}");
});

await engine.RunFlowAsync("MainFlow", progress);
```

### 9.2 å‹å¥½çš„é”™è¯¯æ¶ˆæ¯

**æ”¹è¿›å»ºè®®**:
```csharp
public class UserFriendlyException : Exception
{
    public string UserMessage { get; }
    public string TechnicalDetails { get; }
    public string SuggestedAction { get; }
    
    public UserFriendlyException(
        string userMessage,
        string technicalDetails,
        string suggestedAction)
    {
        UserMessage = userMessage;
        TechnicalDetails = technicalDetails;
        SuggestedAction = suggestedAction;
    }
}

// ä½¿ç”¨
throw new UserFriendlyException(
    userMessage: "æ— æ³•è¿æ¥åˆ°ç›¸æœº",
    technicalDetails: "Camera connection timeout after 5 seconds",
    suggestedAction: "è¯·æ£€æŸ¥ç›¸æœºç”µæºå’Œç½‘ç»œè¿æ¥");
```

---

## 10. å¯è§‚æµ‹æ€§ ğŸŸ¢

### 10.1 æŒ‡æ ‡æ”¶é›†

**æ”¹è¿›å»ºè®®**:
```csharp
public class FlowMetrics
{
    private static readonly Counter FlowExecutionCount = 
        Metrics.CreateCounter("flow_executions_total", "Total flow executions");
        
    private static readonly Histogram FlowDuration = 
        Metrics.CreateHistogram("flow_duration_seconds", "Flow execution duration");
        
    public void RecordExecution(string flowName, TimeSpan duration, bool success)
    {
        FlowExecutionCount.WithLabels(flowName, success.ToString()).Inc();
        FlowDuration.WithLabels(flowName).Observe(duration.TotalSeconds);
    }
}
```

### 10.2 å¥åº·æ£€æŸ¥

**æ”¹è¿›å»ºè®®**:
```csharp
public interface IHealthCheck
{
    Task<HealthCheckResult> CheckHealthAsync();
}

public class FlowEngineHealthCheck : IHealthCheck
{
    public async Task<HealthCheckResult> CheckHealthAsync()
    {
        var checks = new[]
        {
            CheckMQTTConnection(),
            CheckDevicesReady(),
            CheckFlowsRunning()
        };
        
        var results = await Task.WhenAll(checks);
        
        return results.All(r => r.IsHealthy)
            ? HealthCheckResult.Healthy()
            : HealthCheckResult.Unhealthy("Some checks failed");
    }
}
```

---

## ğŸ“Š å®æ–½å»ºè®®

### ä¼˜å…ˆçº§è·¯çº¿å›¾

#### ç¬¬ä¸€é˜¶æ®µ (1-2ä¸ªæœˆ) - åŸºç¡€ä¼˜åŒ–
- âœ… ç»Ÿä¸€å¼‚å¸¸å¤„ç†
- âœ… å¼‚æ­¥ç¼–ç¨‹æ”¹è¿›
- âœ… ç»“æ„åŒ–æ—¥å¿—
- âœ… åŸºç¡€å•å…ƒæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µ (3-4ä¸ªæœˆ) - æ¶æ„é‡æ„
- âœ… ä¾èµ–æ³¨å…¥æ”¹é€ 
- âœ… æ¥å£æŠ½è±¡
- âœ… äº‹ä»¶æ€»çº¿æ¨¡å¼
- âœ… é…ç½®ç®¡ç†ä¼˜åŒ–

#### ç¬¬ä¸‰é˜¶æ®µ (5-6ä¸ªæœˆ) - æ€§èƒ½ä¸è´¨é‡
- âœ… å†…å­˜ä¼˜åŒ–
- âœ… å¹¶å‘æ§åˆ¶ä¼˜åŒ–
- âœ… å®Œå–„æµ‹è¯•è¦†ç›–
- âœ… æ€§èƒ½æµ‹è¯•

#### ç¬¬å››é˜¶æ®µ (æŒç»­) - å¢å¼ºä¸ç»´æŠ¤
- âœ… å¯è§‚æµ‹æ€§å¢å¼º
- âœ… æ–‡æ¡£å®Œå–„
- âœ… å®‰å…¨æ€§åŠ å›º
- âœ… ç”¨æˆ·ä½“éªŒä¼˜åŒ–

### åº¦é‡æŒ‡æ ‡

å»ºç«‹ä»¥ä¸‹æŒ‡æ ‡æ¥è¡¡é‡æ”¹è¿›æ•ˆæœï¼š

1. **æ€§èƒ½æŒ‡æ ‡**
   - æµç¨‹å¹³å‡æ‰§è¡Œæ—¶é—´
   - å†…å­˜ä½¿ç”¨å³°å€¼
   - å¹¶å‘å¤„ç†èƒ½åŠ›

2. **è´¨é‡æŒ‡æ ‡**
   - ä»£ç è¦†ç›–ç‡ (ç›®æ ‡ > 80%)
   - é™æ€ä»£ç åˆ†æå¾—åˆ†
   - Bugæ•°é‡è¶‹åŠ¿

3. **å¯ç»´æŠ¤æ€§æŒ‡æ ‡**
   - ä»£ç é‡å¤ç‡
   - åœˆå¤æ‚åº¦
   - æ–‡æ¡£å®Œæ•´åº¦

---

## ğŸ”§ å·¥å…·æ¨è

### ä»£ç è´¨é‡å·¥å…·
- **SonarQube** - ä»£ç è´¨é‡åˆ†æ
- **ReSharper** - ä»£ç é‡æ„å’Œæ£€æŸ¥
- **StyleCop** - ä»£ç é£æ ¼æ£€æŸ¥

### æµ‹è¯•å·¥å…·
- **xUnit/NUnit** - å•å…ƒæµ‹è¯•æ¡†æ¶
- **Moq** - Mockæ¡†æ¶
- **BenchmarkDotNet** - æ€§èƒ½æµ‹è¯•

### ç›‘æ§å·¥å…·
- **Prometheus** - æŒ‡æ ‡æ”¶é›†
- **Grafana** - æ•°æ®å¯è§†åŒ–
- **Serilog** - ç»“æ„åŒ–æ—¥å¿—
- **Seq** - æ—¥å¿—æŸ¥è¯¢å’Œåˆ†æ

---

## ğŸ“ æ€»ç»“

æœ¬æ”¹è¿›å»ºè®®æ¶µç›–äº†æ¶æ„ã€æ€§èƒ½ã€ä»£ç è´¨é‡ã€æµ‹è¯•ã€æ–‡æ¡£ç­‰å¤šä¸ªæ–¹é¢ã€‚å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼Œæ¯ä¸ªé˜¶æ®µå®Œæˆåè¯„ä¼°æ•ˆæœï¼ŒåŠæ—¶è°ƒæ•´ç­–ç•¥ã€‚

### å…³é”®æ”¹è¿›ç‚¹

1. **æ¶æ„å±‚é¢** - å¼•å…¥ä¾èµ–æ³¨å…¥ï¼Œæé«˜å¯æµ‹è¯•æ€§
2. **æ€§èƒ½å±‚é¢** - ä¼˜åŒ–å¼‚æ­¥å¤„ç†ï¼Œå‡å°‘å†…å­˜å ç”¨
3. **è´¨é‡å±‚é¢** - å®Œå–„æµ‹è¯•ï¼Œç»Ÿä¸€ç¼–ç è§„èŒƒ
4. **è¿ç»´å±‚é¢** - å¢å¼ºå¯è§‚æµ‹æ€§ï¼Œä¾¿äºé—®é¢˜å®šä½

### é¢„æœŸæ”¶ç›Š

- ğŸ“ˆ **æ€§èƒ½æå‡** - 30%ä»¥ä¸Šçš„æ€§èƒ½æ”¹è¿›
- ğŸ› **Bugå‡å°‘** - 50%ä»¥ä¸Šçš„Bugå‡å°‘
- ğŸ”§ **å¯ç»´æŠ¤æ€§** - æ˜¾è‘—æå‡ä»£ç å¯ç»´æŠ¤æ€§
- ğŸ“Š **å¯è§‚æµ‹æ€§** - å®Œå–„çš„ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2024å¹´  
**ç»´æŠ¤å›¢é˜Ÿ**: ColorVision å¼€å‘å›¢é˜Ÿ

> ğŸ’¡ æç¤ºï¼šæœ¬æ–‡æ¡£æ˜¯åŸºäºå½“å‰ä»£ç åˆ†ææå‡ºçš„æ”¹è¿›å»ºè®®ï¼Œå…·ä½“å®æ–½æ—¶è¯·æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
