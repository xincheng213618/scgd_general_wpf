# 状态栏信息接口使用指南

## 概述

状态栏信息接口（`IStatusBarInfoProvider`）允许控件在被选中时向主窗口状态栏提供动态的、上下文相关的信息。这种设计使得不同类型的控件可以显示各自特定的状态信息，而无需修改主窗口代码。

## 核心接口

### IStatusBarInfoProvider

控件通过实现此接口来提供状态栏信息。

```csharp
public interface IStatusBarInfoProvider
{
    ObservableCollection<StatusBarInfoItem> GetStatusBarInfo();
}
```

### StatusBarInfoItem

状态栏信息项类，用于封装单个状态信息。

```csharp
public class StatusBarInfoItem : INotifyPropertyChanged
{
    public string Key { get; set; }              // 信息项的唯一标识
    public string Label { get; set; }            // 显示标签，如 "行:列:", "通道:"
    public string Value { get; set; }            // 信息值
    public string DisplayText { get; }           // 完整的显示文本（标签 + 值）
    public bool IsVisible { get; set; }          // 是否显示此信息项
    public int Order { get; set; }               // 排序顺序，数值越小越靠前
}
```

## 设计理念

1. **解耦性**：控件自己决定要显示什么信息，主窗口只负责呈现
2. **灵活性**：信息项可以动态添加、删除和更新
3. **可观察性**：使用 `ObservableCollection` 和 `INotifyPropertyChanged` 支持自动 UI 更新
4. **标准化**：所有控件使用统一的接口和数据模型

## 使用场景

### 场景 1：图像控件

显示图像相关信息：
- 图像名称
- 比特率
- 通道信息（RGB、灰度等）
- 分辨率
- 颜色空间

### 场景 2：文本编辑控件

显示文本编辑器信息：
- 当前行号
- 当前列号
- 总行数
- 字符总数
- 编码格式

### 场景 3：设备控件

显示设备状态信息（如示例中的光谱仪）：
- 设备名称
- 连接状态
- 工作参数（如积分时间、平均次数）
- 测量模式

## 实现步骤

### 步骤 1：实现接口

在控件类中实现 `IStatusBarInfoProvider` 接口：

```csharp
public partial class MyControl : UserControl, IDisPlayControl, IStatusBarInfoProvider
{
    private ObservableCollection<StatusBarInfoItem> _statusBarInfo;
    
    public ObservableCollection<StatusBarInfoItem> GetStatusBarInfo()
    {
        if (_statusBarInfo == null)
        {
            InitializeStatusBarInfo();
        }
        return _statusBarInfo;
    }
}
```

### 步骤 2：初始化状态栏信息

创建状态栏信息项并设置初始值：

```csharp
private void InitializeStatusBarInfo()
{
    _statusBarInfo = new ObservableCollection<StatusBarInfoItem>
    {
        new StatusBarInfoItem
        {
            Key = "Name",
            Label = "名称:",
            Value = "初始值",
            Order = 0,
            IsVisible = true
        },
        new StatusBarInfoItem
        {
            Key = "Status",
            Label = "状态:",
            Value = "就绪",
            Order = 1,
            IsVisible = true
        }
    };
}
```

### 步骤 3：更新状态信息

当控件状态改变时，更新对应的信息项：

```csharp
private void UpdateStatus(string newStatus)
{
    var statusItem = _statusBarInfo.FirstOrDefault(item => item.Key == "Status");
    if (statusItem != null)
    {
        statusItem.Value = newStatus;  // 自动触发 UI 更新
    }
}
```

### 步骤 4：订阅事件（可选）

如果需要响应外部事件更新状态栏：

```csharp
private void SubscribeToEvents()
{
    SomeService.StatusChanged += (status) =>
    {
        var item = _statusBarInfo.FirstOrDefault(i => i.Key == "Status");
        if (item != null)
        {
            item.Value = GetStatusText(status);
        }
    };
}
```

## 完整示例

以下是 `DisplaySpectrum` 控件的完整实现示例：

```csharp
public partial class DisplaySpectrum : UserControl, IDisPlayControl, IStatusBarInfoProvider
{
    private ObservableCollection<StatusBarInfoItem> _statusBarInfo;

    public ObservableCollection<StatusBarInfoItem> GetStatusBarInfo()
    {
        if (_statusBarInfo == null)
        {
            _statusBarInfo = new ObservableCollection<StatusBarInfoItem>
            {
                new StatusBarInfoItem
                {
                    Key = "DeviceName",
                    Label = "设备:",
                    Value = Device.Config.Name,
                    Order = 0,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "DeviceStatus",
                    Label = "状态:",
                    Value = GetStatusText(SpectrumService.DeviceStatus),
                    Order = 1,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "IntegrationTime",
                    Label = "积分时间:",
                    Value = $"{SpectrumSliderIntTime?.Value ?? 0:F2}ms",
                    Order = 2,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "AverageNumber",
                    Label = "平均次数:",
                    Value = $"{SpectrumSliderAveNum?.Value ?? 0}",
                    Order = 3,
                    IsVisible = true
                }
            };

            // 订阅设备状态变化事件
            SpectrumService.DeviceStatusChanged += (status) =>
            {
                var statusItem = _statusBarInfo.FirstOrDefault(item => item.Key == "DeviceStatus");
                if (statusItem != null)
                {
                    statusItem.Value = GetStatusText(status);
                }
            };

            // 订阅滑块值变化事件
            if (SpectrumSliderIntTime != null)
            {
                SpectrumSliderIntTime.ValueChanged += (s, e) =>
                {
                    var item = _statusBarInfo.FirstOrDefault(i => i.Key == "IntegrationTime");
                    if (item != null)
                    {
                        item.Value = $"{e.NewValue:F2}ms";
                    }
                };
            }

            if (SpectrumSliderAveNum != null)
            {
                SpectrumSliderAveNum.ValueChanged += (s, e) =>
                {
                    var item = _statusBarInfo.FirstOrDefault(i => i.Key == "AverageNumber");
                    if (item != null)
                    {
                        item.Value = $"{e.NewValue}";
                    }
                };
            }
        }

        return _statusBarInfo;
    }

    private string GetStatusText(DeviceStatusType status)
    {
        return status switch
        {
            DeviceStatusType.Unknown => "未知",
            DeviceStatusType.Unauthorized => "未授权",
            DeviceStatusType.OffLine => "离线",
            DeviceStatusType.UnInit => "未初始化",
            DeviceStatusType.Closed => "已关闭",
            DeviceStatusType.Opened => "已打开",
            DeviceStatusType.SP_Continuous_Mode => "连续模式",
            _ => status.ToString()
        };
    }
}
```

## 工作原理

1. **选择触发**：用户点击控件时，`DisPlayManager` 将控件标记为选中状态并触发 `Selected` 事件
2. **信息获取**：`MainWindow` 检测到 `Selected` 事件，检查控件是否实现了 `IStatusBarInfoProvider`
3. **状态栏更新**：如果控件实现了接口，调用 `GetStatusBarInfo()` 获取信息并更新状态栏显示
4. **动态更新**：当 `StatusBarInfoItem` 的 `Value` 属性改变时，通过数据绑定自动更新 UI

## 最佳实践

### 1. 延迟初始化

在第一次调用 `GetStatusBarInfo()` 时才初始化信息项，避免不必要的开销：

```csharp
public ObservableCollection<StatusBarInfoItem> GetStatusBarInfo()
{
    if (_statusBarInfo == null)
    {
        InitializeStatusBarInfo();
    }
    return _statusBarInfo;
}
```

### 2. 使用 Key 标识

为每个信息项设置唯一的 `Key`，便于后续查找和更新：

```csharp
var item = _statusBarInfo.FirstOrDefault(i => i.Key == "MyKey");
```

### 3. 合理设置 Order

使用 `Order` 属性控制信息项的显示顺序，建议按重要性递增：

```csharp
new StatusBarInfoItem { Key = "Name", Order = 0 },      // 最重要
new StatusBarInfoItem { Key = "Status", Order = 1 },    
new StatusBarInfoItem { Key = "Details", Order = 2 }    // 次要信息
```

### 4. 控制可见性

使用 `IsVisible` 属性动态控制信息项的显示：

```csharp
item.IsVisible = ShouldShowDetails();
```

### 5. 格式化显示文本

对数值进行适当的格式化，提升可读性：

```csharp
Value = $"{value:F2}ms"        // 保留两位小数
Value = $"{count} 项"          // 添加单位
Value = $"{size / 1024:N0} KB" // 千位分隔符
```

### 6. 资源清理

如果订阅了外部事件，记得在控件销毁时取消订阅：

```csharp
protected override void OnUnloaded(RoutedEventArgs e)
{
    base.OnUnloaded(e);
    SomeService.StatusChanged -= OnStatusChanged;
}
```

## 扩展性

### 添加图标支持

如果需要在状态栏信息中显示图标，可以扩展 `StatusBarInfoItem` 类：

```csharp
public class StatusBarInfoItem : INotifyPropertyChanged
{
    // 现有属性...
    
    public ImageSource Icon { get; set; }  // 添加图标属性
}
```

### 添加工具提示

可以为信息项添加工具提示说明：

```csharp
public class StatusBarInfoItem : INotifyPropertyChanged
{
    // 现有属性...
    
    public string ToolTip { get; set; }  // 添加工具提示
}
```

### 支持点击操作

可以为信息项添加点击事件处理：

```csharp
public class StatusBarInfoItem : INotifyPropertyChanged
{
    // 现有属性...
    
    public Action ClickAction { get; set; }  // 添加点击操作
}
```

## 故障排除

### 问题 1：状态栏没有显示信息

**原因**：控件可能没有正确实现接口或没有被选中。

**解决方案**：
1. 确认控件同时实现了 `IDisPlayControl` 和 `IStatusBarInfoProvider`
2. 确认控件被添加到 `DisPlayManager` 中
3. 确认控件被选中（`IsSelected = true`）

### 问题 2：信息没有动态更新

**原因**：没有正确触发属性更改通知。

**解决方案**：
1. 确保使用 `StatusBarInfoItem.Value` 属性而非字段
2. 确保 `StatusBarInfoItem` 实现了 `INotifyPropertyChanged`
3. 检查是否正确调用了 `OnPropertyChanged`

### 问题 3：信息顺序不正确

**原因**：没有设置 `Order` 属性或设置不当。

**解决方案**：
1. 为所有信息项设置明确的 `Order` 值
2. 按重要性递增设置顺序值

## 总结

`IStatusBarInfoProvider` 接口提供了一种标准化、灵活的方式来显示控件的上下文相关信息。通过实现这个接口，不同类型的控件可以：

- 显示各自特定的状态信息
- 动态更新信息而不影响其他控件
- 保持代码的解耦和可维护性
- 提供一致的用户体验

这种设计遵循了开闭原则（对扩展开放，对修改关闭），使得添加新类型的控件变得简单，而无需修改主窗口或其他现有代码。
