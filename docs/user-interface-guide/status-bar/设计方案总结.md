# 状态栏接口设计方案总结

## 需求回顾

您的需求是：
> 我想要在设计状态栏的接口，在选中控件的时候，显示对应的状态信息，比如图像控件中的比特率、名称、通道信息，又或者是文本编辑控件中的行列、总数信息等，不固定，我希望接口尽可能标准，这样后续的改动小一些。

## 解决方案

### 核心思路

我设计了一个基于接口的、标准化的状态栏信息系统，采用以下核心思路：

1. **定义标准接口** - 让控件"主动"提供状态信息
2. **数据模型分离** - 统一的信息项数据结构
3. **事件驱动更新** - 利用现有的控件选择机制
4. **自动 UI 刷新** - 基于数据绑定的实时更新

### 技术实现

#### 1. 接口设计（IStatusBarInfoProvider）

```csharp
public interface IStatusBarInfoProvider
{
    ObservableCollection<StatusBarInfoItem> GetStatusBarInfo();
}
```

**设计理由**：
- 简单直接，只有一个方法
- 返回集合，支持多个信息项
- 使用 ObservableCollection，支持动态变化

#### 2. 数据模型（StatusBarInfoItem）

```csharp
public class StatusBarInfoItem : INotifyPropertyChanged
{
    public string Key { get; set; }              // 唯一标识
    public string Label { get; set; }            // 标签（如 "名称:"）
    public string Value { get; set; }            // 值（如 "image.jpg"）
    public string DisplayText { get; }           // 完整文本
    public bool IsVisible { get; set; }          // 是否显示
    public int Order { get; set; }               // 排序
}
```

**设计理由**：
- Key 便于查找和更新特定信息项
- Label + Value 分离，便于格式化
- IsVisible 支持动态显示/隐藏
- Order 控制显示顺序
- INotifyPropertyChanged 实现自动 UI 更新

#### 3. 主窗口集成

在 MainWindow 中添加了：
- 状态栏信息显示区域（StatusBarInfoDocker）
- 控件选择事件订阅机制
- 自动更新状态栏的逻辑

**工作流程**：
```
用户点击控件 → 控件 Selected 事件触发 → MainWindow 检查接口
→ 调用 GetStatusBarInfo() → 创建 UI 元素 → 绑定数据 → 显示
```

## 使用示例

### 为图像控件添加状态信息

```csharp
public class ImageViewerControl : UserControl, IDisPlayControl, IStatusBarInfoProvider
{
    private ObservableCollection<StatusBarInfoItem> _statusBarInfo;
    
    public ObservableCollection<StatusBarInfoItem> GetStatusBarInfo()
    {
        if (_statusBarInfo == null)
        {
            _statusBarInfo = new ObservableCollection<StatusBarInfoItem>
            {
                new StatusBarInfoItem
                {
                    Key = "ImageName",
                    Label = "名称:",
                    Value = CurrentImage?.Name ?? "无",
                    Order = 0,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "BitRate",
                    Label = "比特率:",
                    Value = $"{CurrentImage?.BitRate ?? 0} bps",
                    Order = 1,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "Channels",
                    Label = "通道:",
                    Value = CurrentImage?.ChannelInfo ?? "未知",
                    Order = 2,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "Resolution",
                    Label = "分辨率:",
                    Value = $"{CurrentImage?.Width ?? 0}x{CurrentImage?.Height ?? 0}",
                    Order = 3,
                    IsVisible = true
                }
            };
            
            // 订阅图像变化事件
            ImageChanged += (sender, image) =>
            {
                var nameItem = _statusBarInfo.FirstOrDefault(i => i.Key == "ImageName");
                if (nameItem != null) nameItem.Value = image.Name;
                
                var bitRateItem = _statusBarInfo.FirstOrDefault(i => i.Key == "BitRate");
                if (bitRateItem != null) bitRateItem.Value = $"{image.BitRate} bps";
                
                // ... 更新其他项
            };
        }
        return _statusBarInfo;
    }
}
```

### 为文本编辑器添加状态信息

```csharp
public class TextEditorControl : UserControl, IDisPlayControl, IStatusBarInfoProvider
{
    private ObservableCollection<StatusBarInfoItem> _statusBarInfo;
    
    public ObservableCollection<StatusBarInfoItem> GetStatusBarInfo()
    {
        if (_statusBarInfo == null)
        {
            _statusBarInfo = new ObservableCollection<StatusBarInfoItem>
            {
                new StatusBarInfoItem
                {
                    Key = "LineColumn",
                    Label = "行:列:",
                    Value = $"{CurrentLine}:{CurrentColumn}",
                    Order = 0,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "TotalLines",
                    Label = "总行数:",
                    Value = $"{TotalLines}",
                    Order = 1,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "CharCount",
                    Label = "字符数:",
                    Value = $"{CharacterCount}",
                    Order = 2,
                    IsVisible = true
                },
                new StatusBarInfoItem
                {
                    Key = "Encoding",
                    Label = "编码:",
                    Value = CurrentEncoding?.EncodingName ?? "UTF-8",
                    Order = 3,
                    IsVisible = true
                }
            };
            
            // 订阅光标位置变化
            CaretPositionChanged += (line, col) =>
            {
                var item = _statusBarInfo.FirstOrDefault(i => i.Key == "LineColumn");
                if (item != null) item.Value = $"{line}:{col}";
            };
            
            // 订阅文本变化
            TextChanged += () =>
            {
                var linesItem = _statusBarInfo.FirstOrDefault(i => i.Key == "TotalLines");
                if (linesItem != null) linesItem.Value = $"{TotalLines}";
                
                var charsItem = _statusBarInfo.FirstOrDefault(i => i.Key == "CharCount");
                if (charsItem != null) charsItem.Value = $"{CharacterCount}";
            };
        }
        return _statusBarInfo;
    }
}
```

## 设计优势

### 1. 高度标准化
- 统一的接口定义
- 统一的数据模型
- 统一的更新机制

### 2. 最小化后续改动
- **添加新控件**：只需实现接口，无需修改主窗口
- **修改显示内容**：只需修改控件内部实现
- **调整显示样式**：只需修改主窗口的渲染逻辑

### 3. 灵活且可扩展
- 支持任意数量的信息项
- 支持动态显示/隐藏
- 支持自定义排序
- 易于添加新属性（图标、工具提示等）

### 4. 自动化程度高
- 控件选择自动触发更新
- 数据变化自动刷新 UI
- 无需手动管理 UI 元素

## 关键设计原则

### 开闭原则（Open-Closed Principle）
- **对扩展开放**：可以轻松添加新的控件类型
- **对修改关闭**：不需要修改 MainWindow 或其他现有代码

### 接口隔离原则（Interface Segregation Principle）
- 接口简单明确，只有一个方法
- 控件可以选择实现或不实现

### 依赖倒置原则（Dependency Inversion Principle）
- MainWindow 依赖接口而非具体实现
- 实现了松耦合

### 单一职责原则（Single Responsibility Principle）
- StatusBarInfoItem 只负责数据封装
- IStatusBarInfoProvider 只负责提供数据
- MainWindow 只负责呈现

## 实际应用场景

### 场景 1：设备监控界面
- 设备名称、连接状态
- 工作参数（温度、电压等）
- 测量数据统计

### 场景 2：数据分析界面
- 数据集名称、大小
- 选中数据点数量
- 统计信息（平均值、方差等）

### 场景 3：项目管理界面
- 项目名称、路径
- 文件数量、总大小
- 修改时间

### 场景 4：任意自定义控件
只要实现接口，就能显示任何信息！

## 后续扩展建议

如果将来需要更丰富的功能，可以考虑：

### 1. 添加图标支持
```csharp
public class StatusBarInfoItem
{
    // ... 现有属性
    public ImageSource Icon { get; set; }
}
```

### 2. 添加工具提示
```csharp
public class StatusBarInfoItem
{
    // ... 现有属性
    public string ToolTip { get; set; }
}
```

### 3. 支持点击操作
```csharp
public class StatusBarInfoItem
{
    // ... 现有属性
    public Action ClickAction { get; set; }
}
```

### 4. 支持不同的显示样式
```csharp
public enum StatusBarItemStyle
{
    Text,       // 纯文本
    IconText,   // 图标+文本
    ProgressBar,// 进度条
    Button      // 按钮
}

public class StatusBarInfoItem
{
    // ... 现有属性
    public StatusBarItemStyle Style { get; set; }
}
```

## 迁移指南

对于现有控件，迁移步骤：

1. 让控件类实现 `IStatusBarInfoProvider` 接口
2. 添加 `GetStatusBarInfo()` 方法实现
3. 在方法中创建和返回状态信息项
4. 订阅相关事件，在数据变化时更新信息项的 Value

**无需修改**：
- MainWindow 代码（已经支持）
- 控件的其他功能
- UI 布局

## 总结

这个设计方案完全满足您的需求：

✅ **支持不同控件显示不同信息**
- 图像控件：比特率、名称、通道信息
- 文本编辑器：行列、总数信息
- 任意自定义信息

✅ **接口高度标准化**
- 统一的接口和数据模型
- 一致的实现方式

✅ **最小化后续改动**
- 遵循 SOLID 原则
- 添加新控件无需修改现有代码
- 扩展功能容易

✅ **易于使用和维护**
- 实现简单直接
- 文档完整清晰
- 有完整示例代码

这个方案不仅解决了当前的需求，还为未来的扩展预留了充足的空间，是一个既实用又优雅的解决方案！
