# ColorVision.ImageEditor æ”¹è¿›å»ºè®®

> åŸºäºä»£ç åˆ†æçš„æ”¹è¿›å»ºè®®å’Œä¼˜åŒ–æ–¹å‘

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºå¯¹ ColorVision.ImageEditor é¡¹ç›®çš„æ·±å…¥åˆ†æï¼Œæå‡ºäº†ä¸€ç³»åˆ—æ”¹è¿›å»ºè®®ï¼Œæ—¨åœ¨æå‡ä»£ç è´¨é‡ã€æ€§èƒ½ã€å¯ç»´æŠ¤æ€§å’Œç”¨æˆ·ä½“éªŒã€‚

## ğŸ¯ æ”¹è¿›ä¼˜å…ˆçº§

- ğŸ”´ **é«˜ä¼˜å…ˆçº§** - å½±å“ç³»ç»Ÿç¨³å®šæ€§å’Œæ€§èƒ½ï¼Œå»ºè®®ä¼˜å…ˆå¤„ç†
- ğŸŸ¡ **ä¸­ä¼˜å…ˆçº§** - æå‡ä»£ç è´¨é‡å’Œå¯ç»´æŠ¤æ€§
- ğŸŸ¢ **ä½ä¼˜å…ˆçº§** - å¢å¼ºåŠŸèƒ½å’Œç”¨æˆ·ä½“éªŒ

---

## 1. æ¶æ„ä¼˜åŒ– ğŸ”´

### 1.1 ä¾èµ–æ³¨å…¥æ”¹é€ 

**ç°çŠ¶é—®é¢˜**:
- ç»„ä»¶ä¹‹é—´ç´§è€¦åˆ
- ä¸åˆ©äºå•å…ƒæµ‹è¯•
- éš¾ä»¥è¿›è¡Œæ¨¡æ‹Ÿå’Œéš”ç¦»æµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
// å½“å‰æ–¹å¼ - ç›´æ¥å®ä¾‹åŒ–
public class ImageView
{
    private readonly ComponentManager _manager = new ComponentManager();
}

// å»ºè®®æ”¹ä¸ºä¾èµ–æ³¨å…¥
public class ImageView
{
    private readonly IComponentManager _manager;
    private readonly IImageProcessor _processor;
    
    public ImageView(
        IComponentManager manager,
        IImageProcessor processor)
    {
        _manager = manager;
        _processor = processor;
    }
}
```

**ä¼˜åŠ¿**:
- æé«˜å¯æµ‹è¯•æ€§
- é™ä½è€¦åˆåº¦
- æ”¯æŒå¤šå®ä¾‹åœºæ™¯
- ä¾¿äºMockå’Œå•å…ƒæµ‹è¯•

### 1.2 æ¥å£æŠ½è±¡

**æ”¹è¿›å»ºè®®**:
å®šä¹‰æ ¸å¿ƒæ¥å£ï¼Œæé«˜æ‰©å±•æ€§ï¼š

```csharp
// å›¾åƒå¤„ç†æ¥å£
public interface IImageProcessor
{
    Task<ImageData> ProcessAsync(ImageData input, CancellationToken ct);
    void ApplyFilter(IImageFilter filter);
}

// ç»˜å›¾å·¥å…·æ¥å£
public interface IDrawingTool
{
    string Name { get; }
    Cursor Cursor { get; }
    void OnMouseDown(Point point, DrawingVisualCanvas canvas);
    void OnMouseMove(Point point, DrawingVisualCanvas canvas);
    void OnMouseUp(Point point, DrawingVisualCanvas canvas);
}

// å›¾åƒåŠ è½½å™¨æ¥å£
public interface IImageLoader
{
    bool CanLoad(string filePath);
    Task<ImageData> LoadAsync(string filePath, CancellationToken ct);
}
```

### 1.3 å‘½ä»¤æ¨¡å¼æ”¹è¿›

**ç°çŠ¶é—®é¢˜**:
- æ’¤é”€/é‡åšåŠŸèƒ½å®ç°åˆ†æ•£
- éš¾ä»¥ç»Ÿä¸€ç®¡ç†æ“ä½œå†å²

**æ”¹è¿›å»ºè®®**:
å®ç°ç»Ÿä¸€çš„å‘½ä»¤æ¨¡å¼ï¼š

```csharp
public interface ICommand
{
    void Execute();
    void Undo();
    bool CanExecute();
}

public class CommandManager
{
    private readonly Stack<ICommand> _undoStack = new();
    private readonly Stack<ICommand> _redoStack = new();
    
    public void Execute(ICommand command)
    {
        if (command.CanExecute())
        {
            command.Execute();
            _undoStack.Push(command);
            _redoStack.Clear();
        }
    }
    
    public void Undo()
    {
        if (_undoStack.Count > 0)
        {
            var command = _undoStack.Pop();
            command.Undo();
            _redoStack.Push(command);
        }
    }
    
    public void Redo()
    {
        if (_redoStack.Count > 0)
        {
            var command = _redoStack.Pop();
            command.Execute();
            _undoStack.Push(command);
        }
    }
}

// å…·ä½“å‘½ä»¤ç¤ºä¾‹
public class DrawRectangleCommand : ICommand
{
    private readonly DrawingVisualCanvas _canvas;
    private readonly DVRectangle _rectangle;
    
    public DrawRectangleCommand(DrawingVisualCanvas canvas, DVRectangle rectangle)
    {
        _canvas = canvas;
        _rectangle = rectangle;
    }
    
    public void Execute() => _canvas.AddVisual(_rectangle);
    public void Undo() => _canvas.RemoveVisual(_rectangle);
    public bool CanExecute() => _rectangle != null;
}
```

---

## 2. æ€§èƒ½ä¼˜åŒ– ğŸ”´

### 2.1 å¼‚æ­¥ç¼–ç¨‹æ”¹è¿›

**ç°çŠ¶é—®é¢˜**:
- éƒ¨åˆ†å›¾åƒåŠ è½½å’Œå¤„ç†æ“ä½œåŒæ­¥é˜»å¡UIçº¿ç¨‹
- æœªå……åˆ†åˆ©ç”¨å¼‚æ­¥ç‰¹æ€§

**æ”¹è¿›å»ºè®®**:
```csharp
// å½“å‰åŒæ­¥æ–¹å¼
public void OpenImage(string filePath)
{
    var bitmap = new BitmapImage(new Uri(filePath));
    ImageSource = bitmap;
    // UIçº¿ç¨‹é˜»å¡
}

// æ”¹è¿›åå¼‚æ­¥æ–¹å¼
public async Task OpenImageAsync(string filePath, CancellationToken ct = default)
{
    var bitmap = await Task.Run(() => 
    {
        ct.ThrowIfCancellationRequested();
        return LoadBitmapFromFile(filePath);
    }, ct);
    
    ImageSource = bitmap;
}

// å›¾åƒå¤„ç†å¼‚æ­¥åŒ–
public async Task<Mat> ApplyFilterAsync(
    Mat source, 
    IImageFilter filter,
    IProgress<double> progress = null,
    CancellationToken ct = default)
{
    return await Task.Run(() =>
    {
        var result = new Mat();
        for (int step = 0; step < 100; step++)
        {
            ct.ThrowIfCancellationRequested();
            // å¤„ç†æ­¥éª¤
            progress?.Report(step / 100.0);
        }
        return result;
    }, ct);
}
```

### 2.2 å†…å­˜ä¼˜åŒ–

**æ”¹è¿›å»ºè®®**:

1. **ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›**:
```csharp
public class MatPool
{
    private static readonly ConcurrentBag<Mat> _pool = new();
    
    public static Mat Rent(int rows, int cols, int type)
    {
        if (_pool.TryTake(out var mat) && 
            mat.Rows == rows && mat.Cols == cols && mat.Type() == type)
        {
            return mat;
        }
        return new Mat(rows, cols, type);
    }
    
    public static void Return(Mat mat)
    {
        if (mat != null && !mat.IsDisposed)
        {
            mat.SetTo(new Scalar(0));
            _pool.Add(mat);
        }
    }
}
```

2. **åŠæ—¶é‡Šæ”¾å¤§å¯¹è±¡**:
```csharp
public class ImageView : IDisposable
{
    private Mat _currentImage;
    private WriteableBitmap _displayBitmap;
    
    public void Dispose()
    {
        _currentImage?.Dispose();
        _currentImage = null;
        
        _displayBitmap = null;
        
        GC.SuppressFinalize(this);
    }
}
```

3. **ä½¿ç”¨å¼±å¼•ç”¨ç¼“å­˜**:
```csharp
public class ImageCache
{
    private readonly Dictionary<string, WeakReference<BitmapImage>> _cache = new();
    
    public bool TryGetImage(string key, out BitmapImage image)
    {
        if (_cache.TryGetValue(key, out var weakRef))
        {
            return weakRef.TryGetTarget(out image);
        }
        image = null;
        return false;
    }
    
    public void AddImage(string key, BitmapImage image)
    {
        _cache[key] = new WeakReference<BitmapImage>(image);
    }
}
```

### 2.3 æ¸²æŸ“ä¼˜åŒ–

**æ”¹è¿›å»ºè®®**:

1. **è™šæ‹ŸåŒ–å¤§å›¾åƒæ˜¾ç¤º**:
```csharp
public class VirtualizedImageView
{
    private const int TileSize = 256;
    
    public void RenderVisibleTiles(Rect visibleRect)
    {
        var startTileX = (int)(visibleRect.Left / TileSize);
        var startTileY = (int)(visibleRect.Top / TileSize);
        var endTileX = (int)Math.Ceiling(visibleRect.Right / TileSize);
        var endTileY = (int)Math.Ceiling(visibleRect.Bottom / TileSize);
        
        for (int y = startTileY; y <= endTileY; y++)
        {
            for (int x = startTileX; x <= endTileX; x++)
            {
                RenderTile(x, y);
            }
        }
    }
}
```

2. **ä½¿ç”¨WriteableBitmapä¼˜åŒ–å®æ—¶æ›´æ–°**:
```csharp
public void UpdatePixelsFast(WriteableBitmap bitmap, byte[] pixels)
{
    bitmap.Lock();
    try
    {
        unsafe
        {
            var buffer = (byte*)bitmap.BackBuffer;
            Marshal.Copy(pixels, 0, bitmap.BackBuffer, pixels.Length);
        }
        bitmap.AddDirtyRect(new Int32Rect(0, 0, bitmap.PixelWidth, bitmap.PixelHeight));
    }
    finally
    {
        bitmap.Unlock();
    }
}
```

3. **å‡å°‘ä¸å¿…è¦çš„é‡ç»˜**:
```csharp
public class DrawingVisualCanvas : Canvas
{
    private bool _isDirty = false;
    
    protected override void OnRender(DrawingContext dc)
    {
        if (!_isDirty) return;
        
        base.OnRender(dc);
        _isDirty = false;
    }
    
    public void InvalidateCanvas()
    {
        _isDirty = true;
        InvalidateVisual();
    }
}
```

### 2.4 GPUåŠ é€Ÿ

**æ”¹è¿›å»ºè®®**:
```csharp
// ä½¿ç”¨GPUåŠ é€Ÿå›¾åƒå¤„ç†
public class GpuImageProcessor
{
    public Mat ProcessWithGpu(Mat source)
    {
        using var gpuMat = new GpuMat();
        gpuMat.Upload(source);
        
        // GPUåŠ é€Ÿçš„æ»¤æ³¢
        var gaussianFilter = Cv2.Cuda.CreateGaussianFilter(
            gpuMat.Type(), gpuMat.Type(), new Size(5, 5), 1.5);
        
        using var result = new GpuMat();
        gaussianFilter.Apply(gpuMat, result);
        
        var output = new Mat();
        result.Download(output);
        return output;
    }
}
```

---

## 3. é”™è¯¯å¤„ç†ä¸æ—¥å¿— ğŸ”´

### 3.1 ç»Ÿä¸€å¼‚å¸¸å¤„ç†

**æ”¹è¿›å»ºè®®**:
```csharp
// å®šä¹‰å¼‚å¸¸å±‚æ¬¡
public class ImageEditorException : Exception
{
    public string ImagePath { get; set; }
    public ImageEditorException(string message) : base(message) { }
    public ImageEditorException(string message, Exception inner) : base(message, inner) { }
}

public class ImageLoadException : ImageEditorException
{
    public ImageLoadException(string path, Exception inner) 
        : base($"Failed to load image: {path}", inner)
    {
        ImagePath = path;
    }
}

public class ImageProcessException : ImageEditorException
{
    public string Operation { get; set; }
    public ImageProcessException(string operation, Exception inner)
        : base($"Image processing failed: {operation}", inner)
    {
        Operation = operation;
    }
}

// å…¨å±€å¼‚å¸¸å¤„ç†å™¨
public class ImageEditorExceptionHandler
{
    private static readonly NLog.Logger Logger = NLog.LogManager.GetCurrentClassLogger();
    
    public async Task<T> ExecuteWithHandlingAsync<T>(
        Func<Task<T>> action,
        string operationName)
    {
        try
        {
            return await action();
        }
        catch (ImageLoadException ex)
        {
            Logger.Error(ex, $"Failed to load image: {ex.ImagePath}");
            MessageBox.Show($"æ— æ³•åŠ è½½å›¾åƒ: {ex.ImagePath}\n{ex.Message}", 
                "é”™è¯¯", MessageBoxButton.OK, MessageBoxImage.Error);
            return default;
        }
        catch (OutOfMemoryException ex)
        {
            Logger.Error(ex, "Out of memory during image operation");
            MessageBox.Show("å†…å­˜ä¸è¶³ï¼Œè¯·å°è¯•å…³é—­å…¶ä»–å›¾åƒæˆ–å‡å°å›¾åƒå°ºå¯¸", 
                "å†…å­˜ä¸è¶³", MessageBoxButton.OK, MessageBoxImage.Warning);
            return default;
        }
        catch (Exception ex)
        {
            Logger.Error(ex, $"Unexpected error in {operationName}");
            MessageBox.Show($"æ“ä½œå¤±è´¥: {ex.Message}", 
                "é”™è¯¯", MessageBoxButton.OK, MessageBoxImage.Error);
            return default;
        }
    }
}
```

### 3.2 ç»“æ„åŒ–æ—¥å¿—

**æ”¹è¿›å»ºè®®**:
```csharp
// ä½¿ç”¨NLogæˆ–Serilogè¿›è¡Œç»“æ„åŒ–æ—¥å¿—
public class ImageViewLogger
{
    private static readonly NLog.Logger Logger = NLog.LogManager.GetCurrentClassLogger();
    
    public void LogImageOpened(string filePath, long fileSize, TimeSpan loadTime)
    {
        Logger.Info(
            "Image opened: {FilePath}, Size: {FileSize} bytes, LoadTime: {LoadTime}ms",
            filePath, fileSize, loadTime.TotalMilliseconds);
    }
    
    public void LogDrawingOperation(string toolName, Point start, Point end)
    {
        Logger.Debug(
            "Drawing {Tool} from ({X1},{Y1}) to ({X2},{Y2})",
            toolName, start.X, start.Y, end.X, end.Y);
    }
    
    public void LogPerformanceMetric(string operation, TimeSpan duration, long memoryUsed)
    {
        if (duration.TotalMilliseconds > 1000)
        {
            Logger.Warn(
                "Slow operation: {Operation} took {Duration}ms, Memory: {Memory} MB",
                operation, duration.TotalMilliseconds, memoryUsed / 1024 / 1024);
        }
    }
}
```

### 3.3 æ“ä½œå®¡è®¡

**æ”¹è¿›å»ºè®®**:
```csharp
public class ImageEditAudit
{
    private readonly List<AuditEntry> _auditLog = new();
    
    public void LogEdit(string operation, string details)
    {
        _auditLog.Add(new AuditEntry
        {
            Timestamp = DateTime.Now,
            Operation = operation,
            Details = details,
            User = Environment.UserName
        });
    }
    
    public void ExportAuditLog(string filePath)
    {
        var json = JsonConvert.SerializeObject(_auditLog, Formatting.Indented);
        File.WriteAllText(filePath, json);
    }
}

public class AuditEntry
{
    public DateTime Timestamp { get; set; }
    public string Operation { get; set; }
    public string Details { get; set; }
    public string User { get; set; }
}
```

---

## 4. ä»£ç è´¨é‡ ğŸŸ¡

### 4.1 å‘½åè§„èŒƒ

**ç°çŠ¶é—®é¢˜**:
- éƒ¨åˆ†å˜é‡å‘½åä¸å¤Ÿæ¸…æ™°
- å‘½åé£æ ¼ä¸ç»Ÿä¸€

**æ”¹è¿›å»ºè®®**:
```csharp
// ä¸æ¨è
public float m_begin_val;  // ä¸‹åˆ’çº¿å‘½åï¼Œç¼©å†™ä¸æ¸…æ™°
private Mat _currentMat;   // ä½¿ç”¨ç¼©å†™
public void DoWork() { }   // åŠ¨è¯ä¸æ˜ç¡®

// æ¨è
public float BeginValue { get; set; }  // Pascalå‘½åï¼Œå®Œæ•´å•è¯
private Mat _currentImage;              // å®Œæ•´æœ‰æ„ä¹‰çš„åç§°
public async Task ProcessImageAsync() { }  // æ¸…æ™°çš„åŠ¨è¯+å¼‚æ­¥åç¼€
```

### 4.2 ä»£ç å¤ç”¨

**æ”¹è¿›å»ºè®®**:

1. **æå–å…¬å…±åŸºç±»**:
```csharp
public abstract class BaseDrawingVisual : DrawingVisual
{
    public abstract string TypeName { get; }
    public Guid ID { get; } = Guid.NewGuid();
    public bool IsSelected { get; set; }
    
    protected BaseDrawingVisual()
    {
        Initialize();
    }
    
    protected virtual void Initialize() { }
    
    public abstract void Render(DrawingContext dc);
    public abstract bool HitTest(Point point);
    public abstract Rect GetBounds();
}

// å…·ä½“å®ç°
public class DVRectangle : BaseDrawingVisual
{
    public override string TypeName => "Rectangle";
    
    public override void Render(DrawingContext dc)
    {
        dc.DrawRectangle(Attribute.Brush, Attribute.Pen, Attribute.Rect);
    }
    
    public override bool HitTest(Point point)
    {
        return Attribute.Rect.Contains(point);
    }
    
    public override Rect GetBounds() => Attribute.Rect;
}
```

2. **æå–å·¥å…·ç±»**:
```csharp
public static class ImageHelper
{
    public static BitmapSource MatToBitmapSource(Mat mat)
    {
        // å®ç°Matåˆ°BitmapSourceçš„è½¬æ¢
    }
    
    public static Mat BitmapSourceToMat(BitmapSource source)
    {
        // å®ç°BitmapSourceåˆ°Matçš„è½¬æ¢
    }
    
    public static Size CalculateScaledSize(Size original, Size container, ScaleMode mode)
    {
        // è®¡ç®—ç¼©æ”¾åçš„å°ºå¯¸
    }
}

public static class GeometryHelper
{
    public static double CalculateDistance(Point p1, Point p2)
    {
        return Math.Sqrt(Math.Pow(p2.X - p1.X, 2) + Math.Pow(p2.Y - p1.Y, 2));
    }
    
    public static double CalculateAngle(Point p1, Point p2, Point p3)
    {
        // è®¡ç®—ä¸‰ç‚¹ä¹‹é—´çš„è§’åº¦
    }
}
```

### 4.3 SOLIDåŸåˆ™åº”ç”¨

**æ”¹è¿›å»ºè®®**:

1. **å•ä¸€èŒè´£åŸåˆ™**:
```csharp
// å½“å‰ï¼šImageViewæ‰¿æ‹…è¿‡å¤šèŒè´£
public class ImageView
{
    public void LoadImage() { }
    public void SaveImage() { }
    public void DrawRectangle() { }
    public void AdjustBrightness() { }
    public void ShowHistogram() { }
}

// æ”¹è¿›ï¼šèŒè´£åˆ†ç¦»
public class ImageLoader
{
    public Task<ImageData> LoadAsync(string path) { }
}

public class ImageSaver
{
    public Task SaveAsync(ImageData data, string path) { }
}

public class DrawingManager
{
    public void AddShape(IDrawingShape shape) { }
}

public class ImageAdjuster
{
    public void AdjustBrightness(double value) { }
    public void AdjustContrast(double value) { }
}
```

2. **å¼€é—­åŸåˆ™**:
```csharp
// ä½¿ç”¨ç­–ç•¥æ¨¡å¼æ”¯æŒä¸åŒçš„å›¾åƒå¤„ç†ç®—æ³•
public interface IImageFilter
{
    Mat Apply(Mat source);
}

public class GaussianBlurFilter : IImageFilter
{
    public int KernelSize { get; set; } = 5;
    
    public Mat Apply(Mat source)
    {
        var result = new Mat();
        Cv2.GaussianBlur(source, result, new Size(KernelSize, KernelSize), 0);
        return result;
    }
}

public class ImageFilterPipeline
{
    private readonly List<IImageFilter> _filters = new();
    
    public void AddFilter(IImageFilter filter) => _filters.Add(filter);
    
    public Mat ApplyFilters(Mat source)
    {
        var result = source.Clone();
        foreach (var filter in _filters)
        {
            var temp = filter.Apply(result);
            result.Dispose();
            result = temp;
        }
        return result;
    }
}
```

---

## 5. åŠŸèƒ½å¢å¼º ğŸŸ¢

### 5.1 é«˜çº§ç¼–è¾‘åŠŸèƒ½

**æ”¹è¿›å»ºè®®**:

1. **å›¾å±‚æ”¯æŒ**:
```csharp
public class Layer
{
    public string Name { get; set; }
    public bool IsVisible { get; set; } = true;
    public double Opacity { get; set; } = 1.0;
    public BlendMode BlendMode { get; set; } = BlendMode.Normal;
    public List<IDrawingShape> Shapes { get; } = new();
}

public class LayerManager
{
    public ObservableCollection<Layer> Layers { get; } = new();
    public Layer ActiveLayer { get; set; }
    
    public Layer AddLayer(string name)
    {
        var layer = new Layer { Name = name };
        Layers.Add(layer);
        return layer;
    }
    
    public void MergeDown(Layer layer)
    {
        // åˆå¹¶å›¾å±‚
    }
    
    public void RenderLayers(DrawingContext dc)
    {
        foreach (var layer in Layers.Where(l => l.IsVisible))
        {
            dc.PushOpacity(layer.Opacity);
            foreach (var shape in layer.Shapes)
            {
                shape.Render(dc);
            }
            dc.Pop();
        }
    }
}
```

2. **é€‰åŒºå·¥å…·**:
```csharp
public interface ISelectionTool
{
    Region CreateSelection(Point[] points);
}

public class RectangleSelectionTool : ISelectionTool
{
    public Region CreateSelection(Point[] points)
    {
        var rect = new Rect(points[0], points[1]);
        return new RectRegion(rect);
    }
}

public class LassoSelectionTool : ISelectionTool
{
    public Region CreateSelection(Point[] points)
    {
        var geometry = new PathGeometry();
        var figure = new PathFigure { StartPoint = points[0] };
        
        for (int i = 1; i < points.Length; i++)
        {
            figure.Segments.Add(new LineSegment(points[i], true));
        }
        
        geometry.Figures.Add(figure);
        return new GeometryRegion(geometry);
    }
}
```

3. **æ»¤é•œæ•ˆæœ**:
```csharp
public class FilterLibrary
{
    public static readonly IImageFilter Sharpen = new SharpenFilter();
    public static readonly IImageFilter EdgeDetect = new EdgeDetectFilter();
    public static readonly IImageFilter Emboss = new EmbossFilter();
    
    public static IEnumerable<IImageFilter> GetAllFilters()
    {
        yield return new GaussianBlurFilter();
        yield return new MedianBlurFilter();
        yield return Sharpen;
        yield return EdgeDetect;
        yield return Emboss;
        yield return new BilateralFilter();
    }
}
```

### 5.2 æ‰¹å¤„ç†åŠŸèƒ½

**æ”¹è¿›å»ºè®®**:
```csharp
public class BatchProcessor
{
    public async Task ProcessBatchAsync(
        IEnumerable<string> filePaths,
        IImageFilter filter,
        string outputFolder,
        IProgress<BatchProgress> progress,
        CancellationToken ct)
    {
        var files = filePaths.ToList();
        var completed = 0;
        
        await Parallel.ForEachAsync(files, 
            new ParallelOptions 
            { 
                MaxDegreeOfParallelism = Environment.ProcessorCount,
                CancellationToken = ct 
            },
            async (filePath, token) =>
            {
                var image = await LoadImageAsync(filePath, token);
                var processed = filter.Apply(image);
                var outputPath = Path.Combine(outputFolder, Path.GetFileName(filePath));
                await SaveImageAsync(processed, outputPath, token);
                
                Interlocked.Increment(ref completed);
                progress?.Report(new BatchProgress 
                { 
                    Total = files.Count, 
                    Completed = completed,
                    CurrentFile = filePath
                });
            });
    }
}

public class BatchProgress
{
    public int Total { get; set; }
    public int Completed { get; set; }
    public string CurrentFile { get; set; }
    public double Percentage => (double)Completed / Total * 100;
}
```

### 5.3 AIåŠŸèƒ½é›†æˆ

**æ”¹è¿›å»ºè®®**:
```csharp
public class AIImageEnhancer
{
    // æ™ºèƒ½å»å™ª
    public async Task<Mat> DenoisingAsync(Mat source)
    {
        // ä½¿ç”¨ML.NETæˆ–ONNXæ¨¡å‹è¿›è¡Œæ™ºèƒ½å»å™ª
        return await Task.Run(() =>
        {
            var result = new Mat();
            Cv2.FastNlMeansDenoisingColored(source, result);
            return result;
        });
    }
    
    // è‡ªåŠ¨è‰²å½©æ ¡æ­£
    public async Task<Mat> AutoColorCorrectionAsync(Mat source)
    {
        return await Task.Run(() =>
        {
            // ä½¿ç”¨ç›´æ–¹å›¾å‡è¡¡åŒ–å’Œè‡ªåŠ¨ç™½å¹³è¡¡
            var lab = new Mat();
            Cv2.CvtColor(source, lab, ColorConversionCodes.BGR2Lab);
            
            var channels = Cv2.Split(lab);
            Cv2.EqualizeHist(channels[0], channels[0]);
            
            Cv2.Merge(channels, lab);
            
            var result = new Mat();
            Cv2.CvtColor(lab, result, ColorConversionCodes.Lab2BGR);
            
            return result;
        });
    }
    
    // å†…å®¹æ„ŸçŸ¥å¡«å……
    public async Task<Mat> ContentAwareFillAsync(Mat source, Mat mask)
    {
        return await Task.Run(() =>
        {
            var result = new Mat();
            Cv2.Inpaint(source, mask, result, 3, InpaintMethod.Telea);
            return result;
        });
    }
}
```

---

## 6. ç”¨æˆ·ä½“éªŒä¼˜åŒ– ğŸŸ¡

### 6.1 å¿«æ·é”®ç³»ç»Ÿ

**æ”¹è¿›å»ºè®®**:
```csharp
public class KeyboardShortcutManager
{
    private readonly Dictionary<KeyGesture, ICommand> _shortcuts = new();
    
    public void RegisterShortcut(KeyGesture gesture, ICommand command)
    {
        _shortcuts[gesture] = command;
    }
    
    public void RegisterDefaultShortcuts()
    {
        RegisterShortcut(new KeyGesture(Key.Z, ModifierKeys.Control), UndoCommand);
        RegisterShortcut(new KeyGesture(Key.Y, ModifierKeys.Control), RedoCommand);
        RegisterShortcut(new KeyGesture(Key.S, ModifierKeys.Control), SaveCommand);
        RegisterShortcut(new KeyGesture(Key.O, ModifierKeys.Control), OpenCommand);
        RegisterShortcut(new KeyGesture(Key.Plus, ModifierKeys.Control), ZoomInCommand);
        RegisterShortcut(new KeyGesture(Key.Minus, ModifierKeys.Control), ZoomOutCommand);
        RegisterShortcut(new KeyGesture(Key.F, ModifierKeys.Control), FitToWindowCommand);
        RegisterShortcut(new KeyGesture(Key.D1, ModifierKeys.Control), SelectToolCommand);
    }
    
    public bool HandleKeyPress(KeyEventArgs e)
    {
        var gesture = new KeyGesture(e.Key, Keyboard.Modifiers);
        if (_shortcuts.TryGetValue(gesture, out var command) && command.CanExecute(null))
        {
            command.Execute(null);
            e.Handled = true;
            return true;
        }
        return false;
    }
}
```

### 6.2 å·¥å…·æç¤ºå’Œå¸®åŠ©

**æ”¹è¿›å»ºè®®**:
```csharp
public class ContextualHelpProvider
{
    public string GetToolHelp(string toolName)
    {
        return toolName switch
        {
            "Rectangle" => "å•å‡»å¹¶æ‹–åŠ¨ä»¥ç»˜åˆ¶çŸ©å½¢\næŒ‰ä½Shifté”®ç»˜åˆ¶æ­£æ–¹å½¢",
            "Circle" => "å•å‡»å¹¶æ‹–åŠ¨ä»¥ç»˜åˆ¶æ¤­åœ†\næŒ‰ä½Shifté”®ç»˜åˆ¶æ­£åœ†",
            "Line" => "å•å‡»èµ·ç‚¹ï¼Œç§»åŠ¨é¼ æ ‡ï¼Œå†æ¬¡å•å‡»ç»ˆç‚¹",
            "Text" => "å•å‡»ä½ç½®å¼€å§‹è¾“å…¥æ–‡æœ¬",
            _ => "æœªçŸ¥å·¥å…·"
        };
    }
    
    public void ShowQuickTip(string message, Point location)
    {
        var tooltip = new ToolTip
        {
            Content = message,
            IsOpen = true,
            PlacementTarget = Application.Current.MainWindow,
            Placement = PlacementMode.Mouse
        };
        
        var timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(3) };
        timer.Tick += (s, e) =>
        {
            tooltip.IsOpen = false;
            timer.Stop();
        };
        timer.Start();
    }
}
```

### 6.3 è¿›åº¦æŒ‡ç¤º

**æ”¹è¿›å»ºè®®**:
```csharp
public class ProgressIndicator
{
    public async Task ShowProgressAsync(
        Func<IProgress<double>, CancellationToken, Task> operation,
        string title = "å¤„ç†ä¸­...")
    {
        var progressWindow = new ProgressWindow { Title = title };
        var progress = new Progress<double>(value =>
        {
            progressWindow.ProgressValue = value;
            progressWindow.ProgressText = $"{value:F1}%";
        });
        
        var cts = new CancellationTokenSource();
        progressWindow.CancelRequested += (s, e) => cts.Cancel();
        
        progressWindow.Show();
        
        try
        {
            await operation(progress, cts.Token);
        }
        finally
        {
            progressWindow.Close();
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
await _progressIndicator.ShowProgressAsync(async (progress, ct) =>
{
    for (int i = 0; i < 100; i++)
    {
        ct.ThrowIfCancellationRequested();
        await ProcessStepAsync(i);
        progress.Report(i);
    }
}, "åº”ç”¨æ»¤é•œ...");
```

### 6.4 æœ€è¿‘æ–‡ä»¶åˆ—è¡¨

**æ”¹è¿›å»ºè®®**:
```csharp
public class RecentFileManager
{
    private const int MaxRecentFiles = 10;
    private readonly ObservableCollection<RecentFileEntry> _recentFiles = new();
    
    public IEnumerable<RecentFileEntry> RecentFiles => _recentFiles;
    
    public void AddRecentFile(string filePath)
    {
        var existing = _recentFiles.FirstOrDefault(f => 
            f.FilePath.Equals(filePath, StringComparison.OrdinalIgnoreCase));
        
        if (existing != null)
        {
            _recentFiles.Remove(existing);
        }
        
        _recentFiles.Insert(0, new RecentFileEntry
        {
            FilePath = filePath,
            FileName = Path.GetFileName(filePath),
            LastOpened = DateTime.Now
        });
        
        while (_recentFiles.Count > MaxRecentFiles)
        {
            _recentFiles.RemoveAt(_recentFiles.Count - 1);
        }
        
        SaveRecentFiles();
    }
    
    private void SaveRecentFiles()
    {
        var json = JsonConvert.SerializeObject(_recentFiles);
        File.WriteAllText("recent_files.json", json);
    }
    
    public void LoadRecentFiles()
    {
        if (File.Exists("recent_files.json"))
        {
            var json = File.ReadAllText("recent_files.json");
            var files = JsonConvert.DeserializeObject<List<RecentFileEntry>>(json);
            _recentFiles.Clear();
            foreach (var file in files.Where(f => File.Exists(f.FilePath)))
            {
                _recentFiles.Add(file);
            }
        }
    }
}

public class RecentFileEntry
{
    public string FilePath { get; set; }
    public string FileName { get; set; }
    public DateTime LastOpened { get; set; }
}
```

---

## 7. æµ‹è¯•ä¸è´¨é‡ä¿è¯ ğŸŸ¡

### 7.1 å•å…ƒæµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class ImageProcessorTests
{
    private IImageProcessor _processor;
    
    [TestInitialize]
    public void Setup()
    {
        _processor = new ImageProcessor();
    }
    
    [TestMethod]
    public async Task ProcessAsync_WithValidImage_ShouldReturnProcessedImage()
    {
        // Arrange
        var input = CreateTestImage(100, 100);
        var filter = new GaussianBlurFilter();
        
        // Act
        var result = await _processor.ProcessAsync(input, filter, CancellationToken.None);
        
        // Assert
        Assert.IsNotNull(result);
        Assert.AreEqual(100, result.Width);
        Assert.AreEqual(100, result.Height);
    }
    
    [TestMethod]
    public async Task ProcessAsync_WithCancellation_ShouldThrowOperationCanceledException()
    {
        // Arrange
        var input = CreateTestImage(1000, 1000);
        var filter = new SlowFilter();
        var cts = new CancellationTokenSource();
        cts.CancelAfter(100);
        
        // Act & Assert
        await Assert.ThrowsExceptionAsync<OperationCanceledException>(
            () => _processor.ProcessAsync(input, filter, cts.Token));
    }
    
    private ImageData CreateTestImage(int width, int height)
    {
        var mat = new Mat(height, width, MatType.CV_8UC3, new Scalar(128, 128, 128));
        return new ImageData { Image = mat };
    }
}
```

### 7.2 é›†æˆæµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class ImageViewIntegrationTests
{
    [TestMethod]
    public async Task LoadAndSaveImage_ShouldPreserveImageData()
    {
        // Arrange
        var imageView = new ImageView();
        var testImagePath = "test_image.png";
        var outputPath = "output_image.png";
        
        // Act
        await imageView.OpenImageAsync(testImagePath);
        await imageView.SaveImageAsync(outputPath);
        
        // Assert
        Assert.IsTrue(File.Exists(outputPath));
        
        var originalHash = CalculateImageHash(testImagePath);
        var savedHash = CalculateImageHash(outputPath);
        Assert.AreEqual(originalHash, savedHash);
    }
    
    private string CalculateImageHash(string filePath)
    {
        using var mat = Cv2.ImRead(filePath);
        using var hash = new MD5CryptoServiceProvider();
        var data = new byte[mat.DataEnd.ToInt64() - mat.DataStart.ToInt64()];
        Marshal.Copy(mat.Data, data, 0, data.Length);
        var hashBytes = hash.ComputeHash(data);
        return BitConverter.ToString(hashBytes);
    }
}
```

### 7.3 æ€§èƒ½æµ‹è¯•

**æ”¹è¿›å»ºè®®**:
```csharp
[TestClass]
public class PerformanceTests
{
    [TestMethod]
    public void ImageLoading_ShouldCompleteWithin2Seconds()
    {
        // Arrange
        var imageView = new ImageView();
        var testImagePath = "large_test_image.png";
        var stopwatch = Stopwatch.StartNew();
        
        // Act
        imageView.OpenImage(testImagePath);
        stopwatch.Stop();
        
        // Assert
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 2000,
            $"Image loading took {stopwatch.ElapsedMilliseconds}ms");
    }
    
    [TestMethod]
    public void DrawingOperations_ShouldHandle1000Shapes()
    {
        // Arrange
        var canvas = new DrawingVisualCanvas();
        var stopwatch = Stopwatch.StartNew();
        
        // Act
        for (int i = 0; i < 1000; i++)
        {
            var rect = new DVRectangle
            {
                Attribute = new RectangleAttribute
                {
                    Rect = new Rect(i % 100 * 10, i / 100 * 10, 50, 50)
                }
            };
            canvas.AddVisual(rect);
        }
        
        canvas.UpdateLayout();
        stopwatch.Stop();
        
        // Assert
        Assert.IsTrue(stopwatch.ElapsedMilliseconds < 1000,
            $"Drawing 1000 shapes took {stopwatch.ElapsedMilliseconds}ms");
    }
}
```

---

## 8. æ–‡æ¡£æ”¹è¿› ğŸŸ¢

### 8.1 ä»£ç æ–‡æ¡£

**æ”¹è¿›å»ºè®®**:
```csharp
/// <summary>
/// å›¾åƒè§†å›¾æ§ä»¶ï¼Œæä¾›å›¾åƒæ˜¾ç¤ºã€ç¼–è¾‘å’Œæ ‡æ³¨åŠŸèƒ½
/// </summary>
/// <remarks>
/// æ­¤æ§ä»¶æ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š
/// - å¤šæ ¼å¼å›¾åƒåŠ è½½ï¼ˆPNG, JPG, BMP, TIFF, RGB48ç­‰ï¼‰
/// - ç¼©æ”¾ã€å¹³ç§»å’Œæ—‹è½¬
/// - ç»˜å›¾å·¥å…·ï¼ˆçŸ©å½¢ã€åœ†å½¢ã€çº¿æ¡ã€æ–‡æœ¬ç­‰ï¼‰
/// - å›¾åƒè°ƒæ•´ï¼ˆäº®åº¦ã€å¯¹æ¯”åº¦ã€Gammaç­‰ï¼‰
/// - æ’¤é”€/é‡åšæ“ä½œ
/// 
/// ä½¿ç”¨ç¤ºä¾‹ï¼š
/// <code>
/// var imageView = new ImageView();
/// await imageView.OpenImageAsync("path/to/image.png");
/// imageView.DrawingTool = DrawingToolType.Rectangle;
/// </code>
/// </remarks>
public class ImageView : UserControl
{
    /// <summary>
    /// å¼‚æ­¥åŠ è½½å›¾åƒæ–‡ä»¶
    /// </summary>
    /// <param name="filePath">å›¾åƒæ–‡ä»¶è·¯å¾„</param>
    /// <param name="ct">å–æ¶ˆä»¤ç‰Œï¼Œç”¨äºå–æ¶ˆé•¿æ—¶é—´è¿è¡Œçš„åŠ è½½æ“ä½œ</param>
    /// <returns>è¡¨ç¤ºå¼‚æ­¥æ“ä½œçš„ä»»åŠ¡</returns>
    /// <exception cref="ImageLoadException">å½“å›¾åƒåŠ è½½å¤±è´¥æ—¶æŠ›å‡º</exception>
    /// <exception cref="FileNotFoundException">å½“æ–‡ä»¶ä¸å­˜åœ¨æ—¶æŠ›å‡º</exception>
    public async Task OpenImageAsync(string filePath, CancellationToken ct = default)
    {
        // å®ç°...
    }
}
```

### 8.2 ç”¨æˆ·æ–‡æ¡£

**æ”¹è¿›å»ºè®®**:

åˆ›å»ºè¯¦ç»†çš„ç”¨æˆ·æŒ‡å—ï¼ŒåŒ…æ‹¬ï¼š

1. **å¿«é€Ÿå…¥é—¨æŒ‡å—**
2. **åŠŸèƒ½è¯¦è§£**
3. **å¸¸è§é—®é¢˜è§£ç­”**
4. **æ€§èƒ½ä¼˜åŒ–å»ºè®®**
5. **æ•…éšœæ’é™¤**

### 8.3 APIæ–‡æ¡£

**æ”¹è¿›å»ºè®®**:

ä½¿ç”¨DocFXæˆ–Sandcastleç”Ÿæˆä¸“ä¸šçš„APIæ–‡æ¡£ï¼š

```xml
<!-- Directory.Build.props -->
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <NoWarn>$(NoWarn);1591</NoWarn>
</PropertyGroup>
```

---

## 9. å…¼å®¹æ€§ä¸éƒ¨ç½² ğŸŸ¡

### 9.1 è·¨å¹³å°æ”¯æŒ

**æ”¹è¿›å»ºè®®**:
```csharp
// ä½¿ç”¨æ¡ä»¶ç¼–è¯‘æ”¯æŒä¸åŒå¹³å°
public class PlatformImageLoader
{
#if WINDOWS
    public BitmapSource LoadImageWindows(string path)
    {
        return new BitmapImage(new Uri(path));
    }
#endif

#if LINUX || MACOS
    public SKBitmap LoadImageCrossPlatform(string path)
    {
        return SKBitmap.Decode(path);
    }
#endif
}
```

### 9.2 ç‰ˆæœ¬å…¼å®¹

**æ”¹è¿›å»ºè®®**:
```csharp
public class ConfigVersionManager
{
    public const string CurrentVersion = "2.0.0";
    
    public void MigrateConfig(string configPath)
    {
        var config = LoadConfig(configPath);
        
        if (config.Version != CurrentVersion)
        {
            config = config.Version switch
            {
                "1.0.0" => MigrateFrom_1_0_0(config),
                "1.5.0" => MigrateFrom_1_5_0(config),
                _ => config
            };
            
            config.Version = CurrentVersion;
            SaveConfig(config, configPath);
        }
    }
}
```

---

## 10. å®‰å…¨æ€§ ğŸ”´

### 10.1 è¾“å…¥éªŒè¯

**æ”¹è¿›å»ºè®®**:
```csharp
public class ImageValidator
{
    private static readonly string[] AllowedExtensions = 
        { ".png", ".jpg", ".jpeg", ".bmp", ".tiff", ".tif" };
    
    private const long MaxFileSize = 100 * 1024 * 1024; // 100MB
    
    public ValidationResult ValidateImageFile(string filePath)
    {
        if (!File.Exists(filePath))
        {
            return ValidationResult.Failed("æ–‡ä»¶ä¸å­˜åœ¨");
        }
        
        var extension = Path.GetExtension(filePath).ToLowerInvariant();
        if (!AllowedExtensions.Contains(extension))
        {
            return ValidationResult.Failed("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼");
        }
        
        var fileInfo = new FileInfo(filePath);
        if (fileInfo.Length > MaxFileSize)
        {
            return ValidationResult.Failed("æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶");
        }
        
        if (!IsValidImageFile(filePath))
        {
            return ValidationResult.Failed("æ–‡ä»¶å†…å®¹æ— æ•ˆ");
        }
        
        return ValidationResult.Success();
    }
    
    private bool IsValidImageFile(string filePath)
    {
        try
        {
            using var mat = Cv2.ImRead(filePath, ImreadModes.Unchanged);
            return mat != null && !mat.Empty();
        }
        catch
        {
            return false;
        }
    }
}

public class ValidationResult
{
    public bool IsValid { get; set; }
    public string Message { get; set; }
    
    public static ValidationResult Success() => 
        new ValidationResult { IsValid = true };
    
    public static ValidationResult Failed(string message) => 
        new ValidationResult { IsValid = false, Message = message };
}
```

### 10.2 å®‰å…¨çš„æ–‡ä»¶æ“ä½œ

**æ”¹è¿›å»ºè®®**:
```csharp
public class SecureFileHandler
{
    public async Task<string> SaveImageSecurelyAsync(
        Mat image, 
        string suggestedPath,
        CancellationToken ct)
    {
        // æ¸…ç†æ–‡ä»¶è·¯å¾„ï¼Œé˜²æ­¢è·¯å¾„éå†æ”»å‡»
        var sanitizedPath = SanitizeFilePath(suggestedPath);
        
        // ç¡®ä¿ç›®å½•å­˜åœ¨ä¸”æœ‰å†™æƒé™
        var directory = Path.GetDirectoryName(sanitizedPath);
        if (!HasWritePermission(directory))
        {
            throw new UnauthorizedAccessException($"æ— æƒå†™å…¥ç›®å½•: {directory}");
        }
        
        // ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ï¼Œç¡®ä¿åŸå­æ€§æ“ä½œ
        var tempPath = Path.GetTempFileName();
        
        try
        {
            await Task.Run(() => Cv2.ImWrite(tempPath, image), ct);
            
            if (File.Exists(sanitizedPath))
            {
                File.Delete(sanitizedPath);
            }
            
            File.Move(tempPath, sanitizedPath);
            return sanitizedPath;
        }
        catch
        {
            if (File.Exists(tempPath))
            {
                File.Delete(tempPath);
            }
            throw;
        }
    }
    
    private string SanitizeFilePath(string path)
    {
        var fileName = Path.GetFileName(path);
        var directory = Path.GetDirectoryName(path);
        
        // ç§»é™¤éæ³•å­—ç¬¦
        var invalidChars = Path.GetInvalidFileNameChars();
        fileName = string.Join("_", fileName.Split(invalidChars));
        
        return Path.Combine(directory, fileName);
    }
    
    private bool HasWritePermission(string directory)
    {
        try
        {
            var testFile = Path.Combine(directory, $"test_{Guid.NewGuid()}.tmp");
            File.WriteAllText(testFile, "test");
            File.Delete(testFile);
            return true;
        }
        catch
        {
            return false;
        }
    }
}
```

---

## æ€»ç»“

æœ¬æ–‡æ¡£æå‡ºçš„æ”¹è¿›å»ºè®®æ¶µç›–äº†æ¶æ„ã€æ€§èƒ½ã€ä»£ç è´¨é‡ã€åŠŸèƒ½ã€ç”¨æˆ·ä½“éªŒã€æµ‹è¯•ã€æ–‡æ¡£ã€å…¼å®¹æ€§å’Œå®‰å…¨æ€§ç­‰å¤šä¸ªæ–¹é¢ã€‚å»ºè®®æŒ‰ç…§ä¼˜å…ˆçº§é€æ­¥å®æ–½ï¼š

### é«˜ä¼˜å…ˆçº§ ğŸ”´
1. æ€§èƒ½ä¼˜åŒ–ï¼ˆå¼‚æ­¥ç¼–ç¨‹ã€å†…å­˜ç®¡ç†ï¼‰
2. é”™è¯¯å¤„ç†å®Œå–„
3. å®‰å…¨æ€§åŠ å¼º

### ä¸­ä¼˜å…ˆçº§ ğŸŸ¡
1. æ¶æ„é‡æ„ï¼ˆä¾èµ–æ³¨å…¥ã€æ¥å£æŠ½è±¡ï¼‰
2. ä»£ç è´¨é‡æå‡
3. æµ‹è¯•è¦†ç›–

### ä½ä¼˜å…ˆçº§ ğŸŸ¢
1. åŠŸèƒ½å¢å¼º
2. ç”¨æˆ·ä½“éªŒä¼˜åŒ–
3. æ–‡æ¡£å®Œå–„

å®æ–½è¿™äº›æ”¹è¿›å°†æ˜¾è‘—æå‡ ColorVision.ImageEditor çš„è´¨é‡ã€æ€§èƒ½å’Œå¯ç»´æŠ¤æ€§ï¼Œä¸ºç”¨æˆ·æä¾›æ›´å¥½çš„ä½¿ç”¨ä½“éªŒã€‚
